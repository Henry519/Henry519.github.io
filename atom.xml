<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Henry的博客</title>
  <subtitle>有理想的人，生活总是火热的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-26T13:44:30.367Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Henry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发-App签名的原理</title>
    <link href="http://yoursite.com/2018/07/12/iOS%E5%BC%80%E5%8F%91-App%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/12/iOS开发-App签名的原理/</id>
    <published>2018-07-12T07:10:20.000Z</published>
    <updated>2019-02-26T13:44:30.367Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。</p>
<blockquote>
<p>目的</p>
</blockquote>
<p>先来看看苹果的签名机制是为了做什么。在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。</p>
<blockquote>
<p>非对称加密</p>
</blockquote>
<p>通常我们说的签名就是数字签名，它是基于非对称加密算法实现的。对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。</p>
<p>简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的：</p>
<pre><code>1.选两个质数 p 和 q，相乘得出一个大整数n，例如 p=61，q=53，n=pq=3233
2.选 1-n 间的随便一个质数 e，例如 e = 17
3.经过一系列数学公式，算出一个数字 d，满足：
    a. 通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。
    b. 如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。
</code></pre><p>上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用公钥加密，私钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥（只知道 n 和 e）的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而n数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。</p>
<p>若对数字 d 是怎样计算出来的感兴趣，可以详读这两篇文章：RSA 算法原理<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="external">(一)</a> <a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="external">(二)</a></p>
<blockquote>
<p>数字签名</p>
</blockquote>
<p>现在知道了有非对称加密这东西，那数字签名是怎么回事呢？</p>
<p>数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。</p>
<p>有了上述非对称加密算法，就可以实现这个需求：</p>
<p><img src="/2018/07/12/iOS开发-App签名的原理/01.png" alt=""></p>
<pre><code>1、首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。
2、生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。
3、对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。
4、用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。
</code></pre><p>之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位/ 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。</p>
<p>好了，有了非对称加密的基础，知道了数字签名是什么，怎样可以保证一份数据是经过某个地方认证的，来看看怎样通过数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果认证允许的。</p>
<h3 id="最简单的签名"><a href="#最简单的签名" class="headerlink" title="最简单的签名"></a>最简单的签名</h3><p>要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。</p>
<p><img src="/2018/07/12/iOS开发-App签名的原理/02.png" alt=""></p>
<p>如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。</p>
<p>但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：</p>
<pre><code>1、开发 App 时可以直接把开发中的应用安装进手机进行调试。
2、In-House 企业内部分发，可以直接安装企业证书签名后的 APP。
3、AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。
</code></pre><p>苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。</p>
<blockquote>
<p>新的需求</p>
</blockquote>
<p>我们先来看第一个，开发时安装APP，它有两个个需求：</p>
<pre><code>1、安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。
2、苹果必须对这里的安装有控制权，包括
    a.经过苹果允许才可以这样安装。
    b.不能被滥用导致非开发app也能被安装。
</code></pre><p>为了实现这些需求，iOS 签名的复杂度也就开始增加了。</p>
<p>苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：</p>
<p><img src="/2018/07/12/iOS开发-App签名的原理/03.png" alt=""></p>
<pre><code>1、在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local
2、苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple
3、把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。
4、在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。
5、在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。
6、验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）
</code></pre><blockquote>
<p>加点东西</p>
</blockquote>
<p>上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。</p>
<p>怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。</p>
<p><img src="/2018/07/12/iOS开发-App签名的原理/04.png" alt=""></p>
<p>可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。</p>
<blockquote>
<p>最终流程</p>
</blockquote>
<p>到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。</p>
<p>实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。</p>
<p>所以整个流程稍微变一下，就变成这样了：</p>
<p><img src="/2018/07/12/iOS开发-App签名的原理/05.png" alt=""></p>
<p>因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：</p>
<pre><code>1、在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local
2、苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple
3、把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。
4、在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。
5、在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 `embedded.mobileprovision`，把 APP 安装到手机上。
6、在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 `embedded.mobileprovision` 的数字签名是否正确，里面的证书签名也会再验一遍。
7、确保了 `embedded.mobileprovision` 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。
</code></pre><p>开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。</p>
<h3 id="概念和操作"><a href="#概念和操作" class="headerlink" title="概念和操作"></a>概念和操作</h3><p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p>
<pre><code>第1步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 `CertificateSigningRequest` 就是公钥，私钥保存在本地电脑里。
第2步苹果处理，不用管。
第3步对应把 `CertificateSigningRequest` 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第1步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 `.p12` 文件，其他 Mac 打开后就导入了这个私钥。
第4步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 `Provisioning Profile` 文件。
第5步 XCode 会通过第3步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 `Provisioning Profile` 文件命名为 `embedded.mobileprovision` 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 `_CodeSignature` 目录下。
</code></pre><p>第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</p>
<p>这里再总结一下这些概念：</p>
<pre><code>1、证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。
2、Entitlements：包含了 App 权限开关列表。
3、CertificateSigningRequest：本地公钥。
4、p12：本地私钥，可以导入到其他电脑。
5、Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。
</code></pre><h3 id="其他发布方式"><a href="#其他发布方式" class="headerlink" title="其他发布方式"></a>其他发布方式</h3><p>前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。</p>
<p>而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 <code>embedded.mobileprovision</code> 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。</p>
<p>据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 <code>embedded.mobileprovision</code>去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。</p>
<p>那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 <code>Provisioning Profile</code>？猜测因为苹果想做统一管理，<code>Provisioning Profile</code> 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 <code>Provisioning Profile</code> 里，上传 AppStore 时只要用同样的流程验证这个 <code>Provisioning Profile</code> 是否合法就可以了。</p>
<p>所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。</p>
<p>到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>最后，感谢各位能改耐心看完，也希望能够对大家带来帮助。同时也感谢<a href="http://www.cocoachina.com/ios/20170602/19427.html" target="_blank" rel="external">原作者</a>的文章。本篇文章主要是为了做笔记。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python实践二、数据分析</title>
    <link href="http://yoursite.com/2018/05/11/Python%E5%AE%9E%E8%B7%B5%E4%BA%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/11/Python实践二数据分析/</id>
    <published>2018-05-11T03:29:33.000Z</published>
    <updated>2019-02-26T13:37:21.132Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章的起因是我一个朋友发表博士论文中要对采集的数据进行分析拟合，自然就想到身为程序猿的我了，本人本着无私奉献的精神及哥们义气，就帮了这个忙啦，😁（装逼结束进入正题）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">需求一：根据公式计算MVD、MDN</div><div class="line">MND计算公式：[Σ(Bin Diameter*Num)]/Σnum</div><div class="line">MVD计算公式：ΣVolum/Σnum=4/3*pi*r^3</div><div class="line">计算结果写入Excel表中</div><div class="line">需求二：通道合并及对数正态分布拟合（这个是什么我也不懂，反正就根据公式进行拟合吧）</div></pre></td></tr></table></figure>
<p>俗话说工欲善其事必先利其器，做事之前我们得找些高效的工具。这里我们选择Python中的结构化数据分析利器-Pandas，写入Excel时要用到xlsxwriter库，现在首先安装这两个库。我们打开PyCharm(很好用的Python解释器)点击PyCharm Community Edition -&gt; Preferences首先点击右上角箭头下拉选择Python2.7然后再按图示箭头选择</p>
<p><img src="/2018/05/11/Python实践二数据分析/01.png" alt=""></p>
<p><img src="/2018/05/11/Python实践二数据分析/02.png" alt=""></p>
<h5 id="安装完成开始写代码，首先解决需求一，先看一下数据格式"><a href="#安装完成开始写代码，首先解决需求一，先看一下数据格式" class="headerlink" title="安装完成开始写代码，首先解决需求一，先看一下数据格式"></a>安装完成开始写代码，首先解决需求一，先看一下数据格式</h5><p><img src="/2018/05/11/Python实践二数据分析/03.png" alt=""></p>
<p>要想分析数据我们得读取数据，我们的数据格式是.csv文件，首先我们用Pandas读取数据的格式为<code>table = pd.read_csv(path,names=list(&#39;abcde&#39;),na_values = [&quot;um&quot;,&quot;(Lower)&quot;,&quot;Diff.&quot;,&quot;Volume&quot;,&quot;Number&quot;,&quot;um^3&quot;,&quot;um^2&quot;])</code>其中path为文件地址，names为读取出数据后每列的标识，因为我们的数据最多前五列有用，其他无用数据舍去，所以用abcde标识5列数据。这里要注意的是na_values参数，因为有7000个表，每个表中的数据格式有可能不一样，这里我们要过滤表中的<code>&quot;um&quot;,&quot;(Lower)&quot;,&quot;Diff.&quot;,&quot;Volume&quot;,&quot;Number&quot;,&quot;um^3&quot;,&quot;um^2&quot;</code>数据。运行程序看看读取的数据长什么样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">                          a                     b             c        d  \</div><div class="line">0               Multisizer 3       2017-5-12 10:50           NaN      NaN   </div><div class="line">1                 File name:   DD2016Ter_10_01.#m3           NaN      NaN   </div><div class="line">2                  Group ID:             DD2016Ter           NaN      NaN   </div><div class="line">3                 Sample ID:                    10           NaN      NaN   </div><div class="line">4              Control mode:  Volumetric,  250  uL           NaN      NaN   </div><div class="line">5                  Acquired:       2017-5-12 10:49           NaN      NaN   </div><div class="line">6                 Size bins:                   300           NaN      NaN   </div><div class="line">7                       From                     1           NaN      NaN   </div><div class="line">8                         To                    30           NaN      NaN   </div><div class="line">9          Sizing threshold:                0.9995           NaN      NaN   </div><div class="line">10             Total pulses:                  7044           NaN      NaN   </div><div class="line">11       Counting threshold:                0.9995           NaN      NaN   </div><div class="line">12   Counts above threshold:                  7044           NaN      NaN   </div><div class="line">13    Coincidence corrected:                  7092           NaN      NaN   </div><div class="line">14                       NaN                   NaN           NaN      NaN   </div><div class="line">15                Bin Number                   NaN  DD2016Ter_10      NaN   </div><div class="line">16                       NaN          Bin Diameter       _01.#m3      NaN   </div><div class="line">17                       NaN                   NaN           NaN      NaN   </div><div class="line">18                       NaN                   NaN           NaN      NaN   </div><div class="line">19                         1                     1           153  81.4846   </div><div class="line">20                         2                1.0114           149  82.0997   </div><div class="line">21                         3               1.02293           136  77.5293   </div><div class="line">22                         4                1.0346           123  72.5443   </div><div class="line">23                         5               1.04639           121  73.8337   </div><div class="line">24                         6               1.05832           128  80.8072   </div><div class="line">25                         7               1.07039           121  79.0309   </div><div class="line">26                         8                1.0826           126  85.1439   </div><div class="line">27                         9               1.09494           128  89.4878</div></pre></td></tr></table></figure>
<p><strong>what‘s the fuck!</strong> 这是什么乱七八糟的东西，没办法源数据上面就是一大坨没用的描述，既然如此那我们在对数据进行裁剪一下吧这里要提到Pandas对数据切片语法了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#使用标签选取数据：</div><div class="line">df.loc[行标签,列标签]</div><div class="line">df.loc[&apos;a&apos;:&apos;b&apos;]#选取ab两行数据</div><div class="line">df.loc[:,&apos;one&apos;]#选取one列的数据</div><div class="line">#使用位置选取数据：</div><div class="line">df.iloc[行位置,列位置]</div><div class="line">df.iloc[1,1]#选取第二行，第二列的值，返回的为单个值</div><div class="line">df.iloc[0,2],:]#选取第一行及第三行的数据</div><div class="line">df.iloc[0:2,:]#选取第一行到第三行（不包含）的数据</div><div class="line">df.iloc[:,1]#选取所有记录的第一列的值，返回的为一个Series</div><div class="line">df.iloc[1,:]#选取第一行数据，返回的为一个Series</div></pre></td></tr></table></figure>
<p>我们执行<code>data = table.iloc[17:(len(table) - 1), 1:4]</code>表示我们读取数据的第17行开始到表的倒数第一行，第二列到第第四列，看看切片后的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">           b    c         d</div><div class="line">17       NaN  NaN       NaN</div><div class="line">18       NaN  NaN       NaN</div><div class="line">19         1  153   81.4846</div><div class="line">20    1.0114  149   82.0997</div><div class="line">21   1.02293  136   77.5293</div><div class="line">22    1.0346  123   72.5443</div><div class="line">23   1.04639  121   73.8337</div><div class="line">24   1.05832  128   80.8072</div><div class="line">25   1.07039  121   79.0309</div></pre></td></tr></table></figure>
<p>第17，18行没有有用的数据为什么不从19行开始读呢？这个就是因为她给的数据格式不统一！不统一!其他文件里17、18行是有可能有数据的。接下来我们要对缺失数据进行处理<code>data = data.dropna(how=&#39;all&#39;)</code>这句是去除全部是缺失数据的行，是全部，如果一行中只有一个缺失数据是不会被去除的，所以我们再加上一句<code>data = data.fillna(0).astype(float)</code>这句是用0替换掉表中的缺失数据，然后将数据全部转换为float格式，不转换是文本格式没法计算的。最后我们再给data起个别名，便于记忆<code>data.columns = [&#39;BinDiameter&#39;, &#39;Num&#39;, &#39;Volum&#39;]</code>现在我们再看下数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> 	BinDiameter    Num     Volum</div><div class="line">19       1.00000  153.0   81.4846</div><div class="line">20       1.01140  149.0   82.0997</div><div class="line">21       1.02293  136.0   77.5293</div><div class="line">22       1.03460  123.0   72.5443</div><div class="line">23       1.04639  121.0   73.8337</div><div class="line">24       1.05832  128.0   80.8072</div></pre></td></tr></table></figure>
<p>大功告成有木有！这数据是不是很赏心悦目呀！接下来我们终于可以计算MVD，MND了，喜大普奔😂</p>
<p>根据上面的公式我们定义两个方法分别求出MVD，MND</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def mvd(data):</div><div class="line">    # 球体积=ΣVolum/Σnum=4/3*pi()*r^3反推出d大小</div><div class="line">    return ((data[&apos;Volum&apos;].sum() / data[&apos;Num&apos;].sum()) / ((4/3) * math.pi)) **(1.0/3)</div><div class="line">def mnd(data):</div><div class="line">    # [Σ(Bin Diameter*Num)]/ΣNum</div><div class="line">    # Num列数据求和</div><div class="line">    Num = data[&apos;Num&apos;].sum()</div><div class="line">    print(&quot;Num和为 %f&quot; % (Num))</div><div class="line">    # Bin Diameter*Num</div><div class="line">    bn = data[&quot;BinDiameter&quot;] * data[&quot;Num&quot;]</div><div class="line">    print(&quot;BinDiameter*Num的和= %f&quot; % (bn.sum()))</div><div class="line">    return (bn.sum() / Num)</div></pre></td></tr></table></figure>
<p>解释：<code>data[&#39;Volum&#39;].sum()</code>表示Volum列所有数据的求和。<code>data[&quot;BinDiameter&quot;] * data[&quot;Num&quot;]</code>表示BinDiameter列数据对应于Num列数据相乘，一一对应乘积的关系，得出一列数据bn,<code>bn.sum() / data[&#39;Num&#39;].sum()</code>即MND,就是这么简单暴力的计算。</p>
<p>最后我们要将数据写入Excel中，再定义一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def writerWithExcel(mnd,mvd,indexList):</div><div class="line">    df = pd.DataFrame(&#123;&apos;MND&apos;: mnd, &apos;MVD&apos;: mvd&#125;,index=indexList)</div><div class="line">    writer = pd.ExcelWriter(&apos;simple.xlsx&apos;, engine=&apos;xlsxwriter&apos;)</div><div class="line">    df.to_excel(writer, sheet_name=&apos;Sheet1&apos;)</div><div class="line">    writer.save()</div></pre></td></tr></table></figure>
<p>解释：拿到mnd,mvd的值我们先建立DataFrame对象<code>df = pd.DataFrame({&#39;MND&#39;: mnd, &#39;MVD&#39;: mvd},index=indexList)</code>其中index表示每行的标识，这里我们要传入每个样本的名称，然后调用ExcelWriter传入文件名称写入Excel保存。</p>
<p>最后我们看下结果</p>
<p><img src="/2018/05/11/Python实践二数据分析/04.png" alt=""></p>
<p>单个文件处理完成，剩下的就是for循环处理7000个文件了，<strong><a href="https://github.com/Henry519/PythonDataProcess" target="_blank" rel="external">源代码</a></strong>已上传至GitHub。至此需求一已经完成，接下来处理需求二。</p>
<blockquote>
<p>需求二</p>
</blockquote>
<p>在需求一的处理好的数据基础上首先按要求进行通道合并</p>
<p><img src="/2018/05/11/Python实践二数据分析/05.png" alt=""></p>
<p>首先的按要求进行数据切片，按6行一组切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#通道合并</div><div class="line">def calculateWithPerSixRow(data):</div><div class="line">    # 获取第一行的行标签，即切片数据的起始行数</div><div class="line">    startIndex = data.index[0]</div><div class="line">    for x in range(len(data)):</div><div class="line">        if (x % 6 == 0):#对6进行取余</div><div class="line">            endIndex = (startIndex + 6) - 1</div><div class="line">            if endIndex &gt; data.index[-1]:#如果最后一组的末尾行数超过了data的总行数，那此组数据舍去</div><div class="line">                pass</div><div class="line">            else:</div><div class="line">                print &quot;分组数据为%d--------%d行&quot; % (startIndex, endIndex)</div><div class="line">                startIndex = endIndex + 1</div></pre></td></tr></table></figure>
<p>打印一下分组的起始行标识</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">分组数据为19--------24行</div><div class="line">分组数据为25--------30行</div><div class="line">分组数据为31--------36行</div><div class="line">分组数据为37--------42行</div><div class="line">分组数据为43--------48行</div><div class="line">分组数据为49--------54行</div><div class="line">分组数据为55--------60行</div><div class="line">分组数据为61--------66行</div><div class="line">分组数据为67--------72行</div><div class="line">分组数据为73--------78行</div><div class="line">分组数据为79--------84行</div><div class="line">分组数据为85--------90行</div><div class="line">分组数据为91--------96行</div><div class="line">分组数据为97--------102行</div><div class="line">分组数据为103--------108行</div><div class="line">分组数据为109--------114行</div><div class="line">分组数据为115--------120行</div><div class="line">分组数据为121--------126行</div><div class="line">分组数据为127--------132行</div><div class="line">分组数据为133--------138行</div><div class="line">分组数据为139--------144行</div><div class="line">分组数据为145--------150行</div><div class="line">分组数据为151--------156行</div><div class="line">分组数据为157--------162行</div><div class="line">分组数据为163--------168行</div><div class="line">分组数据为169--------174行</div><div class="line">分组数据为175--------180行</div><div class="line">分组数据为181--------186行</div><div class="line">分组数据为187--------192行</div><div class="line">分组数据为193--------198行</div><div class="line">分组数据为199--------204行</div><div class="line">分组数据为205--------210行</div><div class="line">分组数据为211--------216行</div><div class="line">分组数据为217--------222行</div><div class="line">分组数据为223--------228行</div><div class="line">分组数据为229--------234行</div><div class="line">分组数据为235--------240行</div><div class="line">分组数据为241--------246行</div><div class="line">分组数据为247--------252行</div><div class="line">分组数据为253--------258行</div><div class="line">分组数据为259--------264行</div><div class="line">分组数据为265--------270行</div><div class="line">分组数据为271--------276行</div><div class="line">分组数据为277--------282行</div><div class="line">分组数据为283--------288行</div><div class="line">分组数据为289--------294行</div><div class="line">分组数据为295--------300行</div><div class="line">分组数据为301--------306行</div><div class="line">分组数据为307--------312行</div><div class="line">分组数据为313--------318行</div></pre></td></tr></table></figure>
<p>接下来进行数据切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#根据起始index取出对应startIndex到endIndex的行数的数据</div><div class="line">tempData = data.loc[startIndex:endIndex]</div><div class="line">#取出每组数据第一行的值tempData.values是一个二维数组</div><div class="line">firstValue = tempData.values[0][0]</div></pre></td></tr></table></figure>
<p>我们来看一下tempData.values的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">分组数据为19--------24行</div><div class="line">[[   1.       153.        81.4846 ]</div><div class="line"> [   1.0114   149.        82.0997 ]</div><div class="line"> [   1.02293  136.        77.5293 ]</div><div class="line"> [   1.0346   123.        72.5443 ]</div><div class="line"> [   1.04639  121.        73.8337 ]</div><div class="line"> [   1.05832  128.        80.8072 ]]</div><div class="line">分组数据为25--------30行</div><div class="line">[[   1.07039  121.        79.0309 ]</div><div class="line"> [   1.0826   126.        85.1439 ]</div><div class="line"> [   1.09494  128.        89.4878 ]</div><div class="line"> [   1.10742  127.        91.8605 ]</div><div class="line"> [   1.12005  109.        81.5686 ]</div><div class="line"> [   1.13282  122.        94.4555 ]]</div></pre></td></tr></table></figure>
<p>接下来我们把每组数据的值进行计算后存入数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newBD.append(firstValue)#每组数据第一行的值</div><div class="line">newNum.append(tempData[&apos;Num&apos;].sum())#每组数据Num列的求和</div><div class="line">newVolume.append(tempData[&apos;Volum&apos;].sum())#每组数据Volum列的求和</div></pre></td></tr></table></figure>
<p>最后我们再次构造一个DataFrame对象<code>df = pd.DataFrame({&#39;BD&#39;: newBD, &#39;NMU&#39;: newNum, &#39;VOL&#39;: newVolume})</code>打印一下看看结果是不是预期的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> 			BD    NMU        VOL</div><div class="line">0    1.00000  810.0   468.2988</div><div class="line">1    1.07039  733.0   521.5472</div><div class="line">2    1.14574  629.0   547.3834</div><div class="line">3    1.22639  553.0   593.1900</div><div class="line">4    1.31271  523.0   686.8520</div><div class="line">5    1.40512  458.0   735.2066</div><div class="line">6    1.50402  416.0   820.1590</div><div class="line">7    1.60989  377.0   912.7970</div><div class="line">8    1.72321  355.0  1059.7630</div><div class="line">9    1.84451  288.0  1041.7950</div></pre></td></tr></table></figure>
<p>嗯，数据对的，至此通道合并完成。接下来模拟对数正太分别图，我们先看看公式</p>
<p><img src="/2018/05/11/Python实践二数据分析/06.png" alt=""></p>
<p>这里是朋友给的坐标求解方法</p>
<p><img src="/2018/05/11/Python实践二数据分析/07.png" alt=""></p>
<p>其实按公式计算最后拟合结果也是正确的，比这个手动计算微分简单的多，后面我会讲解两种方式拟合</p>
<p>首先我们采用第一种方式：即求得dV/dlnd,这个是y值，x值即为通道合并好的BD的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">def draw(df):</div><div class="line">    # 计算lnd,即对BD列所有的数据应用logBD函数（此函数返回BD列数据以e为底的对数值）</div><div class="line">    lnBD = df.BD.apply(logBD)</div><div class="line">    # 计算Δlnd</div><div class="line">    lndList = []</div><div class="line">    for x in range(0, len(lnBD) - 1):</div><div class="line">        y = x + 1</div><div class="line">        tempNumb = lnBD[y] - lnBD[x]</div><div class="line">        lndList.append(tempNumb)</div><div class="line">    lndList.append(lndList[0])</div><div class="line">    # print df[&apos;VOL&apos;].values</div><div class="line">    # 计算ΔdV / Δlnd</div><div class="line">    they = df[&apos;VOL&apos;].values / lndList</div><div class="line">    thex = df[&apos;BD&apos;].values</div><div class="line">    #画图</div><div class="line">    pl.scatter(thex, they)</div><div class="line">    plt.show()</div></pre></td></tr></table></figure>
<p>计算出x、y的值后，我们绘制出散点图看看是什么形状</p>
<p><img src="/2018/05/11/Python实践二数据分析/08.png" alt=""></p>
<p>接下来我们采用第二种方式来计算：根据上面的公式来求x，y值，看看有什么差别。首先我们得先求出公式里所需要的标准差跟期望值，然后带入函数求y值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#这里求标准差跟期望值是根据合并后BinDiameter的值来进行计算的</div><div class="line">mean = df[&apos;BD&apos;].mean()#期望值</div><div class="line">std = df[&apos;BD&apos;].std()#标准差</div></pre></td></tr></table></figure>
<p>我们定义上面的对数正太分布函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#正态分布函数</div><div class="line">def normfun(x,y,mu,sigma):</div><div class="line">    #x为d,y为Vtotal,mu为BinDiameter的期望值,sigma为BinDiameter的方差</div><div class="line">    pdf = np.exp((((np.log(x) - np.log(mu))/np.log(sigma)) **2) * (-1/2))</div><div class="line">    a =  y/(np.log(sigma) * np.sqrt(2*np.pi))</div><div class="line">    return pdf * a</div></pre></td></tr></table></figure>
<p>求出y值后我们再次绘制下散点图</p>
<p><img src="/2018/05/11/Python实践二数据分析/09.png" alt=""></p>
<p>结果分布趋势相同</p>
<p>最后根据点进行图像拟合存储图片</p>
<p><img src="/2018/05/11/Python实践二数据分析/10.png" alt=""></p>
<h2 id="本文源码"><a href="#本文源码" class="headerlink" title="本文源码"></a><a href="https://github.com/Henry519/PythonDataProcess" target="_blank" rel="external">本文源码</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的起因是我一个朋友发表博士论文中要对采集的数据进行分析拟合，自然就想到身为程序猿的我了，本人本着无私奉献的精神及哥们义气，就帮了这个忙啦，😁（装逼结束进入正题）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python实践一、将网页转换为pdf电子书</title>
    <link href="http://yoursite.com/2018/03/26/Python%E5%BA%94%E7%94%A8%E4%B8%80%E5%B0%86%E7%BD%91%E9%A1%B5%E8%BD%AC%E6%8D%A2%E4%B8%BApdf%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    <id>http://yoursite.com/2018/03/26/Python应用一将网页转换为pdf电子书/</id>
    <published>2018-03-26T06:06:27.000Z</published>
    <updated>2019-02-26T12:43:20.589Z</updated>
    
    <content type="html"><![CDATA[<p>本人是个”收集狂”(不要想歪了哈，我只是喜欢收藏技术贴)，遇到好的东西就喜欢收藏或记录下来，尤其是好的技术文章或者工具。这里就要提到廖雪峰老师的官方网站了，廖老师写的Python、JavaScript、Git教程真心好呀，每每都要去逛逛。于是就有了今天这个需求，把廖老师的教程由网页转为PDF电子书，这样就可以随时随地离线学习加收藏了。说到这里进入今天的主题<strong>Python爬虫实践：将网页转换为pdf电子书</strong></p>
<p>写爬虫似乎没有比用 Python 更合适了，Python 社区提供的爬虫工具多得让你眼花缭乱，各种拿来就可以直接用的 library 分分钟就可以写出一个爬虫出来，今天就琢磨着写一个爬虫，将廖雪峰的 Python 教程 爬下来做成 PDF 电子书方便离线阅读。</p>
<p>开始写爬虫前，我们先来分析一下该网站的页面结构，网页的左侧是教程的目录大纲，每个 URL 对应到右边的一篇文章，右侧上方是文章的标题，中间是文章的正文部分，正文内容是我们关心的重点，我们要爬的数据就是所有网页的正文部分，下方是用户的评论区，评论区对我们没什么用，所以可以忽略它。</p>
<p><img src="/2018/03/26/Python应用一将网页转换为pdf电子书/01.png" alt=""></p>
<p><strong>工具准备</strong></p>
<p>弄清楚了网站的基本结构后就可以开始准备爬虫所依赖的工具包了。requests、beautifulsoup 是爬虫两大神器，reuqests 用于网络请求，beautifusoup 用于操作 html 数据。有了这两把梭子，干起活来利索，scrapy 这样的爬虫框架我们就不用了，小程序派上它有点杀鸡用牛刀的意思。此外，既然是把 html 文件转为 pdf，那么也要有相应的库支持， wkhtmltopdf 就是一个非常好的工具，它可以用适用于多平台的 html 到 pdf 的转换，pdfkit 是 wkhtmltopdf 的Python封装包。首先安装好下面的依赖包，接着安装 wkhtmltopdf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install requests</div><div class="line">pip install beautifulsoup4</div><div class="line">pip install pdfkit</div><div class="line">pip install PyPDF2</div></pre></td></tr></table></figure>
<p>安装 wkhtmltopdf</p>
<p>Ubuntu 和 CentOS 可以直接用命令行进行安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install wkhtmltopdf  # ubuntu</div><div class="line">$ sudo yum intsall wkhtmltopdf      # centos</div></pre></td></tr></table></figure>
<p>Windows平台直接在 wkhtmltopdf 官网2下载稳定版的进行安装，安装完成之后把该程序的执行路径加入到系统环境 $PATH 变量中，否则 pdfkit 找不到 wkhtmltopdf 就出现错误 <code>No wkhtmltopdf executable found</code> <strong>这里就要多说几句了，因为这里处理不好，程序执行<code>pdfkit.from_file(htmls, file_name, options=options)</code>的时候就会报错。</strong></p>
<p>现在开始手动安装wkhtmltopdf（博主电脑操作系统是 macOS 10.12.2）</p>
<p>1、去官网下<strong><a href="https://wkhtmltopdf.org/downloads.html#stable" target="_blank" rel="external">wkhtmltopdf</a></strong>。下载完成运行wkhtmltox-0.12.4_osx-cocoa-x86-64.pkg</p>
<p>2、把wkhtmltoimage和wkhtmltopdf复制到/usr/bin目录，更改所有者，并增加可执行属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sudo cp /usr/local/bin/wkhtmltopdf /usr/bin/</div><div class="line">sudo cp /usr/local/bin/wkhtmltoimage /usr/bin/</div><div class="line">sudo chown root:root /usr/bin/wkhtmltopdf</div><div class="line">sudo chown root:root /usr/bin/wkhtmltoimage</div><div class="line">sudo chmod +x /usr/bin/wkhtmltopdf</div><div class="line">sudo chmod +x /usr/bin/wkhtmltoimage</div></pre></td></tr></table></figure>
<p>不出意外你在执行第一句的时候就会遇到<code>chmod:Unable to change file modle on /usr/bin</code>这是因为苹果从 OS X El Capitan 10.11 系统开始使用了 Rootless 机制，可以将该机制理解为一个更高等级的系统的内核保护措施，系统默认将会锁定 /system、/sbin、/usr 这三个目录。</p>
<p>关闭Rootless</p>
<p>关闭和开启 Rootless 非常简单，方法如下：重启 Mac，听到开机启动声后按下 Command+R，进入恢复模式，在上面的菜单实用工具中找到并打开 Terminal（如果顶部没出现菜单，请继续重启^_^）。输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ csrutil disable #关闭 Rootless</div><div class="line">$ csrutil enable #开启 Rootless</div></pre></td></tr></table></figure>
<p>OK,到此我们工具及环境配置好了，下面开始实现功能。</p>
<p>爬虫实现</p>
<p>一切准备就绪后就可以上代码了，不过写代码之前还是先整理一下思绪。程序的目的是要把所有 URL 对应的 html 正文部分保存到本地，然后利用 pdfkit 把这些文件转换成一个 pdf 文件。我们把任务拆分一下，首先是把某一个 URL 对应的 html 正文保存到本地，然后找到所有的 URL 执行相同的操作。用 Chrome 浏览器找到页面正文部分的标签，按 F12 找到正文对应的 div 标签：<code>&lt;div class=&quot;x-wiki-content&quot;&gt;</code>，该 div 是网页的正文内容。用 requests 把整个页面加载到本地后，就可以使用 beautifulsoup 操作 HTML 的 dom 元素 来提取正文内容了。</p>
<p><img src="/2018/03/26/Python应用一将网页转换为pdf电子书/02.png" alt=""></p>
<p>具体的实现代码如下：用 soup.find_all 函数找到正文标签，然后把正文部分的内容保存到 a.html 文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">def parse_url_to_html(url, name):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    解析URL，返回HTML内容</div><div class="line">    :param url:解析的url</div><div class="line">    :param name: 保存的html文件名</div><div class="line">    :return: html</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    try:</div><div class="line">        response = requests.get(url)</div><div class="line">        soup = BeautifulSoup(response.content, &apos;html.parser&apos;)</div><div class="line">        # 正文</div><div class="line">        body = soup.find_all(class_=&quot;x-wiki-content&quot;)[0]</div><div class="line">        # 标题</div><div class="line">        title = soup.find(&apos;h4&apos;).get_text()</div><div class="line">        # 标题加入到正文的最前面，居中显示</div><div class="line">        center_tag = soup.new_tag(&quot;center&quot;)</div><div class="line">        title_tag = soup.new_tag(&apos;h1&apos;)</div><div class="line">        title_tag.string = title</div><div class="line">        center_tag.insert(1, title_tag)</div><div class="line">        body.insert(1, center_tag)</div><div class="line">        html = str(body)</div><div class="line">        # body中的img标签的src相对路径的改成绝对路径</div><div class="line">        pattern = &quot;(&lt;img .*?src=\&quot;)(.*?)(\&quot;)&quot;</div><div class="line">        def func(m):</div><div class="line">            if not m.group(3).startswith(&quot;http&quot;):</div><div class="line">                rtn = m.group(1) + baseUrl + m.group(2) + m.group(3)</div><div class="line">                return rtn</div><div class="line">            else:</div><div class="line">                return m.group(1)+m.group(2)+m.group(3)</div><div class="line">        html = re.compile(pattern).sub(func, html)</div><div class="line">        html = html_template.format(content=html)</div><div class="line">        html = html.encode(&quot;utf-8&quot;)</div><div class="line">        with open(name, &apos;wb&apos;) as f:</div><div class="line">            f.write(html)</div><div class="line">        return name</div><div class="line">    except Exception as e:</div><div class="line">        logging.error(&quot;解析错误&quot;, exc_info=True)</div></pre></td></tr></table></figure>
<p>第二步就是把页面左侧所有 URL 解析出来。采用同样的方式，找到 左侧菜单标签<ul class="uk-nav uk-nav-side"></ul></p>
<p><img src="/2018/03/26/Python应用一将网页转换为pdf电子书/03.png" alt=""></p>
<p>具体代码实现逻辑：因为页面上有两个uk-nav uk-nav-side的 class 属性，而真正的目录列表是第二个。所有的 url 获取了，url 转 html 的函数在第一步也写好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def get_url_list():</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    获取所有URL目录列表</div><div class="line">    :return:</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    response = requests.get(htmlUrl)</div><div class="line">    soup = BeautifulSoup(response.content, &quot;html.parser&quot;)</div><div class="line">    menu_tag = soup.find_all(class_=&quot;uk-nav uk-nav-side&quot;)[1]</div><div class="line">    urls = []</div><div class="line">    for li in menu_tag.find_all(&quot;li&quot;):</div><div class="line">        url = baseUrl + li.a.get(&apos;href&apos;)</div><div class="line">        urls.append(url)</div><div class="line">    return urls</div></pre></td></tr></table></figure>
<p>最后一步就是把 html 转换成pdf文件了。转换成 pdf 文件非常简单，因为 pdfkit 把所有的逻辑都封装好了，你只需要调用函数 pdfkit.from_file</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">def save_pdf(htmls, file_name):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    把所有html文件保存到pdf文件</div><div class="line">    :param htmls:  html文件列表</div><div class="line">    :param file_name: pdf文件名</div><div class="line">    :return:</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    options = &#123;</div><div class="line">        &apos;page-size&apos;: &apos;Letter&apos;,</div><div class="line">        &apos;margin-top&apos;: &apos;0.75in&apos;,</div><div class="line">        &apos;margin-right&apos;: &apos;0.75in&apos;,</div><div class="line">        &apos;margin-bottom&apos;: &apos;0.75in&apos;,</div><div class="line">        &apos;margin-left&apos;: &apos;0.75in&apos;,</div><div class="line">        &apos;encoding&apos;: &quot;UTF-8&quot;,</div><div class="line">        &apos;custom-header&apos;: [</div><div class="line">            (&apos;Accept-Encoding&apos;, &apos;gzip&apos;)</div><div class="line">        ],</div><div class="line">        &apos;cookie&apos;: [</div><div class="line">            (&apos;cookie-name1&apos;, &apos;cookie-value1&apos;),</div><div class="line">            (&apos;cookie-name2&apos;, &apos;cookie-value2&apos;),</div><div class="line">        ],</div><div class="line">        &apos;outline-depth&apos;: 10,</div><div class="line">    &#125;</div><div class="line">    pdfkit.from_file(htmls, file_name, options=options)</div></pre></td></tr></table></figure>
<p>执行 save_pdf 函数，电子书 pdf 文件就生成了：</p>
<p>程序执行图</p>
<p><img src="/2018/03/26/Python应用一将网页转换为pdf电子书/04.png" alt=""></p>
<p>生成PDF文件</p>
<p><img src="/2018/03/26/Python应用一将网页转换为pdf电子书/05.png" alt=""></p>
<h2 id="点击下载源码"><a href="#点击下载源码" class="headerlink" title="点击下载源码"></a><a href="https://github.com/Henry519/PythonCrawler" target="_blank" rel="external">点击下载源码</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人是个”收集狂”(不要想歪了哈，我只是喜欢收藏技术贴)，遇到好的东西就喜欢收藏或记录下来，尤其是好的技术文章或者工具。这里就要提到廖雪峰老师的官方网站了，廖老师写的Python、JavaScript、Git教程真心好呀，每每都要去逛逛。于是就有了今天这个需求，把廖老师的教
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发-使用Cocoapods创建私有podspec</title>
    <link href="http://yoursite.com/2017/08/17/iOS%E5%BC%80%E5%8F%91-%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89podspec/"/>
    <id>http://yoursite.com/2017/08/17/iOS开发-使用Cocoapods创建私有podspec/</id>
    <published>2017-08-17T02:43:27.000Z</published>
    <updated>2019-02-26T12:56:20.104Z</updated>
    
    <content type="html"><![CDATA[<p>Cocoapods是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。制作共有podSpec可以参考我博客园里另一篇文章<a href="http://www.cnblogs.com/heng-hengHenry/p/5962997.html" target="_blank" rel="external">上传代码到cocoapod</a> ,自己的框架提供给开发者使用。其实共有和私有的区别就在于对podSpec的管理，这里整体先说明一下创建一个私有的podspec包括如下那么几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">创建并设置一个私有的Spec Repo。</div><div class="line">创建Pod的所需要的项目工程文件，并且有可访问的项目版本控制地址。</div><div class="line">创建Pod所对应的podspec文件。</div><div class="line">本地测试配置好的podspec文件是否可用。</div><div class="line">向私有的Spec Repo中提交podspec。</div><div class="line">在个人项目中的Podfile中增加刚刚制作的好的Pod并使用。</div><div class="line">更新维护podspec。</div></pre></td></tr></table></figure>
<p>在这一系列的步骤中需要创建两个Git仓库，分别是第一步和第二步（第二步不一定非要是Git仓库，只要是可以获取到相关代码文件就可以，也可以是SVN的，也可以说zip包，区别就是在podspec中的source项填写的内容不同），<strong>并且第一步只是在初次创建私有podspec时才需要</strong>，之后在创建其他的只需要从第二步开始就可以。本文只介绍在Git环境下的操作，其他环境其他方式暂不说明。</p>
<blockquote>
<p>创建私有Spec Repo</p>
</blockquote>
<p>先来说第一步，什么是Spec Repo？他是所有的Pods的一个索引，就是一个容器，所有公开的Pods都在这个里面，他实际是一个Git仓库remote端在GitHub上，但是当你使用了Cocoapods后他会被clone到本地的~/.cocoapods/repos目录下，可以进入到这个目录看到master文件夹就是这个官方的Spec Repo了。这个master目录的结构是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Specs</div><div class="line">    └── [SPEC_NAME]</div><div class="line">        └── [VERSION]</div><div class="line">            └── [SPEC_NAME].podspec</div></pre></td></tr></table></figure>
<p>因此我们需要创建一个类似于master的私有Spec Repo，这里我们可以fork官方的Repo，也可以自己创建，个人建议不fork，因为你只是想添加自己的Pods，没有必要把现有的公开Pods都copy一份。所以创建一个 Git仓库，这个仓库你可以创建私有的也可以创建公开的，不过既然私有的Spec Repo，还是创建私有的仓库吧，需要注意的就是如果项目中有其他同事共同开发的话，你还要给他这个Git仓库的权限。因为GitHub的私有仓库是收费的，我还不是GitHub的付费用户，所以我使用了其他Git服务，我使用的是开源中国，当然还有其他的可供选择Coding、Bitbucket以及CSDN。创建完成之后在Terminal中执行如下命令：</p>
<p><code>$ pod repo add HXSpecs https://gitee.com/null_536_3468/HXSpecs.git</code></p>
<p>此时如果成功的话进入到~/.cocoapods/repos目录下就可以看到HXSpecs这个目录了。至此第一步创建私有Spec Repo完成。</p>
<p>PS：上述代码只需要在第一次创建私有Spec Repo的时候用到，之后你每次创建其他私有Pod项目只需要从下面的步骤开始。如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可。</p>
<blockquote>
<p>创建Pod项目工程文件</p>
</blockquote>
<p>这一步就跟创建共有Pod项目一样了，首先要创建一个项目托管仓库，共有私有都可以，这里我们还是在开源中国上创建一个名为HRCargary的私有仓库</p>
<p><img src="/2017/08/17/iOS开发-使用Cocoapods创建私有podspec/01.png" alt=""></p>
<p>然后我们把项目克隆岛本地，执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://gitee.com/null_536_3468/HRCargary.git</div></pre></td></tr></table></figure>
<p>我们在刚刚克隆下来的文件夹里在创建一个名为HRCargary的文件夹，里面放着4个文件，这个文件夹就是放我们的组件的。然后再创建一个名为testDemo的文件夹，这个文件夹里放着我的的测试工程项目，如果不需要测试工程也可以不创建。现在看一下我们所克隆下来的项目的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ tree -L 3</div><div class="line">.</div><div class="line">├── HRCargary</div><div class="line">│   ├── UIColor+Extension.h</div><div class="line">│   ├── UIColor+Extension.m</div><div class="line">│   ├── UIImage+Extension.h</div><div class="line">│   └── UIImage+Extension.m</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">└── testDemo</div><div class="line">    └── demo</div><div class="line">        ├── demo</div><div class="line">        └── demo.xcodeproj</div></pre></td></tr></table></figure>
<p>现在我们要把添加的文件push到远程仓库里去了，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add .</div><div class="line">$ git commit -m &quot;添加项目文件&quot;</div><div class="line">$ git push -u origin master</div></pre></td></tr></table></figure>
<p>因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag &apos;1.2.2&apos;</div><div class="line">$ git push --tags</div></pre></td></tr></table></figure>
<blockquote>
<p>创建Pod所对应的podspec文件。</p>
</blockquote>
<p>打开终端定位到克隆的文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /Users/WanYin/Desktop/hr/HRCargary</div></pre></td></tr></table></figure>
<p>然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec create HRCargary.podspec</div></pre></td></tr></table></figure>
<p>这是你会发现多了一个HRCargary.podspec文件，打开它是长这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line">  #名称</div><div class="line">  s.name         = &quot;HRCargary&quot; </div><div class="line">  #版本号</div><div class="line">  s.version      = &quot;1.2.2&quot; </div><div class="line">  #简短介绍，下面是详细介绍</div><div class="line">  s.summary      = &quot;NSString&amp;UIImage的分类&quot; </div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">  好用的分类哈哈哈哈哈哈哈哈哈哈哈哈哈哈</div><div class="line">                   DESC</div><div class="line">  #主页,这里要填写可以访问到的地址，不然验证不通过</div><div class="line">  s.homepage     = &quot;https://gitee.com/null_536_3468/HRCargary&quot;</div><div class="line">  #开源协议</div><div class="line">  s.license      = &quot;MIT&quot; </div><div class="line">  #作者信息</div><div class="line">  s.author             = &#123; &quot;Henry&quot; =&gt; &quot;382782411@qq.com&quot; &#125;</div><div class="line">  #支持的平台及版本</div><div class="line">  s.platform     = :ios, &quot;8.0&quot;</div><div class="line">  #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</div><div class="line">  s.source       = &#123; :git =&gt; &quot;https://gitee.com/null_536_3468/HRCargary.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class="line">  #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</div><div class="line">  s.source_files  = &quot;HRCargary/**/*&quot;</div><div class="line">  #资源文件地址，没有可以不写</div><div class="line">  s.resources = [&quot;testDemo/demo/demo/*.xib&quot;,&quot;testDemo/demo/demo/*.xcassets&quot;]</div><div class="line">  #是否使用ARC</div><div class="line">  s.requires_arc = true</div><div class="line">  #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</div><div class="line">  # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>填写完成后我们再看一下项目最终的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── HRCargary</div><div class="line">│   ├── UIColor+Extension.h</div><div class="line">│   ├── UIColor+Extension.m</div><div class="line">│   ├── UIImage+Extension.h</div><div class="line">│   └── UIImage+Extension.m</div><div class="line">├── HRCargary.podspec</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">└── testDemo</div><div class="line">    └── demo</div><div class="line">        ├── demo</div><div class="line">        └── demo.xcodeproj</div></pre></td></tr></table></figure>
<blockquote>
<p>本地测试配置好的podspec文件是否可用。</p>
</blockquote>
<p>打开终端定位到克隆下来的文件夹后执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec lint ./HRCargary.podspec --allow-warnings</div></pre></td></tr></table></figure>
<p>当你看到时,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-&gt; HRCargary (1.2.2)</div><div class="line">    - WARN  | url: The URL (https://gitee.com/null_536_3468/HRCargary) is not reachable.</div><div class="line">Analyzed 1 podspec.</div><div class="line">HRCargary.podspec passed validation.</div></pre></td></tr></table></figure>
<p>说明验证通过了，不过这只是这个podspec文件是合格的。WARN可以不用管。</p>
<blockquote>
<p>向私有的Spec Repo中提交podspec</p>
</blockquote>
<p>向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。 向我们的私有Spec Repo提交podspec只需要一个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo push HXSpecs HRCargary.podspec  #前面是本地Repo名字 后面是podspec名字</div></pre></td></tr></table></figure>
<p>完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/HXSpecs目录下查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── HRCargary</div><div class="line">│   └── 1.2.2</div><div class="line">│       └── HRCargary.podspec</div><div class="line">└── README.md</div></pre></td></tr></table></figure>
<p>再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ pod search HRCargary</div><div class="line">-&gt; HRCargary (1.2.2)</div><div class="line">   NSString&amp;UIImage的分类</div><div class="line">   pod &apos;HRCargary&apos;, &apos;~&gt; 1.2.2&apos;</div><div class="line">   - Homepage: https://gitee.com/null_536_3468/HRCargary</div><div class="line">   - Source:   https://gitee.com/null_536_3468/HRCargary.git</div><div class="line">   - Versions: 1.2.2, 1.0.0 [master repo]</div></pre></td></tr></table></figure>
<p>Ps:如果搜索不到给个终极解决方法:到 ~/Library/Caches/CocoaPods目录删除search_index.json然后重新搜索就有啦。</p>
<p>接下来我们在项目里可以这样使用私有库组件，在Podfile里增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</div><div class="line">#这里就是你的私有Spec Repo</div><div class="line">source &apos;https://gitee.com/null_536_3468/HXSpecs.git&apos;</div><div class="line">target :test do</div><div class="line">    pod &apos;HRCargary&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<blockquote>
<p>更新维护podspec</p>
</blockquote>
<p>最后再来说一下制作好的podspec文件后续的更新维护工作，比如如何添加新的版本，如何删除Pod。</p>
<p>我已经制作好了HRCargary的1.2.2版本，现在我对他进行升级工作，这次我添加了更多的模块到HRCargary之中，包括工具类，底层Model及UIKit扩展等，这里又尝试了一下subspec功能，给HRCargary创建了多个子分支。</p>
<p>具体做法是先将源文件添加到HRCargary中，然后按照不同的模块对文件目录进行整理，因为我有2个模块，所以在HRCargary下有创建了2个子目录，完成之后继续编辑之前的HRCargary.podspec，这次增加了subspec特性,先看一下HRCargary的文件目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── CommonTools</div><div class="line">│   ├── TimeUtil.h</div><div class="line">│   └── TimeUtil.m</div><div class="line">└── cargary</div><div class="line">    ├── HXTableViewCell.xib</div><div class="line">    ├── UIColor+Extension.h</div><div class="line">    ├── UIColor+Extension.m</div><div class="line">    ├── UIImage+Extension.h</div><div class="line">    └── UIImage+Extension.m</div></pre></td></tr></table></figure>
<p>编辑HRCargary.podspec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line">  #名称</div><div class="line">  s.name         = &quot;HRCargary&quot; </div><div class="line">  #版本号，要跟远程仓库里tag值一样，并且每次更新库都得改变</div><div class="line">  s.version      = &quot;2.2.2&quot; </div><div class="line">  #简短介绍，下面是详细介绍</div><div class="line">  s.summary      = &quot;NSString&amp;UIImage的分类&quot; </div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">  好用的分类哈哈哈哈哈哈哈哈哈哈哈哈哈哈</div><div class="line">                   DESC</div><div class="line">  #主页,这里要填写可以访问到的地址，不然验证不通过</div><div class="line">  s.homepage     = &quot;https://gitee.com/null_536_3468/HRCargary&quot;</div><div class="line">  #开源协议</div><div class="line">  s.license      = &quot;MIT&quot; </div><div class="line">  #作者信息</div><div class="line">  s.author             = &#123; &quot;Henry&quot; =&gt; &quot;382782411@qq.com&quot; &#125;</div><div class="line">  #支持的平台及版本</div><div class="line">  s.platform     = :ios, &quot;8.0&quot;</div><div class="line">  #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</div><div class="line">  s.source       = &#123; :git =&gt; &quot;https://gitee.com/null_536_3468/HRCargary.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</div><div class="line">  #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</div><div class="line">  #s.source_files  = &quot;HRCargary/**/*&quot;</div><div class="line">  #资源文件地址，没有可以不写</div><div class="line">  #s.resources = [&quot;testDemo/demo/demo/*.xib&quot;,&quot;testDemo/demo/demo/*.xcassets&quot;]</div><div class="line">  #是否使用ARC</div><div class="line">  s.requires_arc = true</div><div class="line">  #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</div><div class="line">  # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</div><div class="line">  s.subspec &apos;CommonTools&apos; do |commonTools|</div><div class="line">      commonTools.source_files = &apos;HRCargary/CommonTools/**/*&apos;</div><div class="line">      commonTools.public_header_files = &apos;HRCargary/CommonTools/**/*.h&apos;</div><div class="line">  end</div><div class="line">  s.subspec &apos;cargary&apos; do |cargarys|</div><div class="line">      cargarys.source_files = &apos;HRCargary/cargary/**/*&apos;</div><div class="line">      cargarys.public_header_files = &apos;HRCargary/cargary/**/*.h&apos;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<p>因为我们创建了subspec所以项目整体的依赖dependency，源文件source_files，头文件public_header_files，资源文件resource等都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系。</p>
<p>编辑完成之后，先将个工程push到远端仓库，并打上新的tag-&gt;2.2.2。</p>
<p>最后再次使用<code>$ pod spec lint ./HRCargary.podspec --allow-warnings</code>验证编辑好的podsepc文件，没有自身的ERROR之后，就可以再次提交到Spec Repo中了，命令跟之前是一样的<code>pod repo push HXSpecs HRCargary.podspec</code></p>
<p>完成这些之后，在实际项目中我们就可以选择使用整个组件库或者是组件库的某一个部分了，对应的Podfile中添加的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;8.0&apos;</div><div class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</div><div class="line">#私有Spec Repo</div><div class="line">source &apos;https://gitee.com/null_536_3468/HXSpecs.git&apos;</div><div class="line">target :test do</div><div class="line">    pod &apos;HRCargary&apos; #使用整个库</div><div class="line">    #pod &apos;HRCargary/CommonTools&apos; #使用某一个部分</div><div class="line">    #pod &apos;HRCargary/cargary&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
<p>你会看到组件会以分组的形式存在，如AFNetworking一样，并不会打乱文件目录结构。</p>
<p>最后介绍一下如何删除一个私有Spec Repo，只需要执行一条命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod repo remove HXSpecs</div></pre></td></tr></table></figure>
<p>这样这个Spec Repo就在本地删除了，我们还可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod repo add WTSpecs https://gitee.com/null_536_3468/HXSpecs.git</div></pre></td></tr></table></figure>
<p>再把它给加回来。<br>如果我们要删除私有Spec Repo下的某一个podspec怎么操作呢，此时无需借助Cocoapods，只需要cd到<code>~/.cocoapods/repos/HXSpecs</code>目录下，删掉库目录<code>$ rm -Rf HRCargary</code><br>然后在将Git的变动push到远端仓库即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;remove unuseful pods&quot;</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cocoapods是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。制作共有podSpec可以参考我博客园里另一篇文章&lt;a href=&quot;http://www.cnblogs.com/heng-h
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发-RunLoop实例应用</title>
    <link href="http://yoursite.com/2017/07/28/iOS%E5%BC%80%E5%8F%91-RunLoop%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/07/28/iOS开发-RunLoop实例应用/</id>
    <published>2017-07-28T01:25:09.000Z</published>
    <updated>2019-02-26T13:00:49.410Z</updated>
    
    <content type="html"><![CDATA[<p>之前看过很多有关RunLoop的文章，其中要么是主要介绍RunLoop的基本概念，要么是主要讲解RunLoop的底层原理，很少用真正的实例来讲解RunLoop的，这其中有大部分原因是由于大家在项目中很少能用到RunLoop吧。基于这种原因，本文中将用很少的篇幅来对基础内容做以介绍，然后主要利用实例来加深大家对RunLoop的理解,<a href="https://github.com/Henry519/RunLoopDemo" target="_blank" rel="external">本文中的代码</a>已经上传GitHub,大家可以下载查看，有问题欢迎Issue我。本文主要分为如下几个部分:</p>
<ul>
<li>RunLoop的基础知识</li>
<li>初识RunLoop，如何让RunLoop进驻线程</li>
<li>深入理解Perform Selector</li>
<li>一直”活着”的后台线程</li>
<li>深入理解NSTimer</li>
<li>让两个后台线程有依赖性的一种方式</li>
<li>NSURLConnetction的内部实现</li>
<li>AFNetWorking中是如何使用RunLoop的?</li>
<li>其它:利用GCD实现定时器功能</li>
<li>延伸阅读</li>
</ul>
<blockquote>
<p>RunLoop的基本概念:</p>
</blockquote>
<p>什么是RunLoop？提到RunLoop，我们一般都会提到线程，这是为什么呢？先来看下<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">官方</a>对RunLoop的定义:RunLoop系统中和线程相关的基础架构的组成部分(和线程相关)，一个RunLoop是一个事件处理环，系统利用这个事件处理环来安排事务，协调输入的各种事件。RunLoop的目的是让你的线程在有工作的时候忙碌，没有工作的时候休眠(和线程相关)。可能这样说你还不是特别清楚RunLoop究竟是用来做什么的，打个比方来说明:我们把线程比作一辆跑车，把这辆跑车的主人比作RunLoop，那么在没有’主人’的时候，这个跑车的生命是直线型的，其启动，运行完之后就会废弃(没有人对其进行控制，’撞坏’被收回)，当有了RunLoop这个主人之后，‘线程’这辆跑车的生命就有了保障，这个时候，跑车的生命是环形的，并且在主人有比赛任务的时候就会被RunLoop这个主人所唤醒,在没有任务的时候可以休眠(在IOS中，开启线程是很消耗性能的，开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源，以便CPU进行更加高效的工作)，这样可以增加跑车的效率,也就是说RunLoop是为线程所服务的。这个例子有点不是很贴切，线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从<a href="https://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">苹果公开的源码</a>中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式。刚才所说的比赛任务就是唤醒跑车这个线程的一个source;RunLoop Mode就是一系列输入的source,timer以及observer。RunLoop在同一时段只能且必须在一种特定Mode下Run,更换Mode时需要暂停当前的Loop,然后重启新的Loop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDefalutRunLoopMode      默认状态.空闲状态</div><div class="line">UITrackingRunLoopMode     滑动ScrollView</div><div class="line">UIInitializationRunLoopMode    私有,App启动时</div><div class="line">NSRunLoopCommonModes     默认包括上面第一和第二</div></pre></td></tr></table></figure>
<blockquote>
<p>初识RunLoop，如何让RunLoop进驻线程</p>
</blockquote>
<p>我们在主线程中添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">while (1) &#123;</div><div class="line">    NSLog(@&quot;while begin&quot;);</div><div class="line">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">    NSLog(@&quot;%@&quot;,runLoop);</div><div class="line">    [runLoop run];</div><div class="line">    // 不会执行</div><div class="line">    NSLog(@&quot;while end&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候我们可以看到主线程在执行完<code>[runLoop run]</code>; 之后被阻塞而没有执行下面的<code>NSLog(@&quot;while end&quot;)</code>;同时，我们利用GCD，将这段代码放到一个后台线程中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">      </div><div class="line">        while (1) &#123;</div><div class="line">            </div><div class="line">            NSLog(@&quot;while begin&quot;);</div><div class="line">            NSRunLoop *subRunLoop = [NSRunLoop currentRunLoop];</div><div class="line">            [subRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">            NSLog(@&quot;while end&quot;);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>这个时候我们发现这个while循环会一直在执行；这是为什么呢?我们先将这两个RunLoop分别打印出来:</p>
<p><img src="/2017/07/28/iOS开发-RunLoop实例应用/01.png" alt=""></p>
<p>由于这个日志比较长，我就只截取了上面的一部分。<br>我们再看我们新建的子线程中的RunLoop,打印出来之后:</p>
<p><img src="/2017/07/28/iOS开发-RunLoop实例应用/02.png" alt=""></p>
<p>从中可以看出来：我们新建的线程中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sources0 = (null),</div><div class="line">sources1 = (null),</div><div class="line">observers = (null),</div><div class="line">timers = (null),</div></pre></td></tr></table></figure>
<p>我们看到虽然有Mode，但是我们没有给它soures,observer,timer，其实Mode中的这些source,observer,timer，统称为这个Mode的item，如果一个Mode中一个item都没有，则这个RunLoop会直接退出，不进入循环(其实线程之所以可以一直存在就是由于RunLoop将其带入了这个循环中)。下面我们为这个RunLoop添加个source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">      </div><div class="line">        while (1) &#123;</div><div class="line">            </div><div class="line">            NSPort *macPort = [NSPort port];</div><div class="line">            NSLog(@&quot;while begin&quot;);</div><div class="line">            NSRunLoop *subRunLoop = [NSRunLoop currentRunLoop];</div><div class="line">            [subRunLoop addPort:macPort forMode:NSDefaultRunLoopMode];</div><div class="line">            [subRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">            NSLog(@&quot;while end&quot;);</div><div class="line">            NSLog(@&quot;%@&quot;,subRunLoop);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>这样我们可以看到能够实现了和主线程中相同的效果，线程在这个地方暂停了，为什么呢？我们明天让RunLoop在distantFuture之前都一直run的啊？相信大家已经猜出出来了。这个时候线程被RunLoop带到‘坑’里去了，这个‘坑’就是一个循环，在循环中这个线程可以在没有任务的时候休眠，在有任务的时候被唤醒；当然我们只用一个while(1)也可以让这个线程一直存在，但是这个线程会一直在唤醒状态，及时它没有任务也一直处于运转状态，这对于CPU来说是非常不高效的。</p>
<h4 id="小结-我们的RunLoop要想工作，必须要让它存在一个Item-source-observer或者timer-，主线程之所以能够一直存在，并且随时准备被唤醒就是因为系统为其添加了很多Item。"><a href="#小结-我们的RunLoop要想工作，必须要让它存在一个Item-source-observer或者timer-，主线程之所以能够一直存在，并且随时准备被唤醒就是因为系统为其添加了很多Item。" class="headerlink" title="小结:我们的RunLoop要想工作，必须要让它存在一个Item(source,observer或者timer)，主线程之所以能够一直存在，并且随时准备被唤醒就是因为系统为其添加了很多Item。"></a>小结:我们的RunLoop要想工作，必须要让它存在一个Item(source,observer或者timer)，主线程之所以能够一直存在，并且随时准备被唤醒就是因为系统为其添加了很多Item。</h4><blockquote>
<p>探究Perform Selector</p>
</blockquote>
<p>我们先在主线程中使用下performselector:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)tryPerformSelectorOnMianThread&#123;</div><div class="line">    [self performSelector:@selector(mainThreadMethod) withObject:nil];</div><div class="line">&#125;</div><div class="line">- (void)mainThreadMethod&#123;</div><div class="line">    NSLog(@&quot;execute %s&quot;,__func__);</div><div class="line">    // print: execute -[ViewController mainThreadMethod]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们在ViewDidLoad中调用<code>tryPerformSelectorOnMianThread</code>,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];<br>和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    [self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">- (void)backGroundThread&#123;</div><div class="line">    NSLog(@&quot;%u&quot;,[NSThread isMainThread]);</div><div class="line">    NSLog(@&quot;execute %s&quot;,__FUNCTION__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？<br>这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个source0，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    [self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class="line">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">    [runLoop run];</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。</p>
<h4 id="小结-当perform-selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop"><a href="#小结-当perform-selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop" class="headerlink" title="小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop"></a>小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop</h4><blockquote>
<p>一直”活着”的后台线程</p>
</blockquote>
<p>现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">@property(nonatomic,strong) NSThread *myThread;</div><div class="line">@end</div><div class="line">@implementation ViewController</div><div class="line">- (void)alwaysLiveBackGoundThread&#123;</div><div class="line">    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@&quot;etund&quot;];</div><div class="line">    self.myThread = thread;</div><div class="line">    [self.myThread start];</div><div class="line">&#125;</div><div class="line">- (void)myThreadRun&#123;</div><div class="line">    NSLog(@&quot;my thread run&quot;);</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,self.myThread);</div><div class="line">    [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">- (void)doBackGroundThreadWork&#123;</div><div class="line">    NSLog(@&quot;do some work %s&quot;,__FUNCTION__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法中，我们利用一个强引用来获取了后台线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡):。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)myThreadRun&#123;</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</div><div class="line">    [[NSRunLoop currentRunLoop] run];</div><div class="line">    NSLog(@&quot;my thread run&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。</p>
<p><strong>小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在</strong></p>
<blockquote>
<p>探究NSTimer</p>
</blockquote>
<p>我们平时使用NSTimer，一般是在主线程中的，代码大多如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)tryTimerOnMainThread&#123;</div><div class="line">    NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</div><div class="line">    [myTimer fire];</div><div class="line">&#125;</div><div class="line">- (void)timerAction&#123;</div><div class="line">    NSLog(@&quot;timer action&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)tryTimerOnBackGrondThread&#123;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  </div><div class="line">        NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</div><div class="line">        [myTimer fire];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">[runLoop run];</div></pre></td></tr></table></figure>
<p>这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。</p>
<blockquote>
<p>让两个后台线程有依赖性的一种方式</p>
</blockquote>
<p>给两个后台线程添加依赖可能有很多的方式，这里说明一种利用RunLoop实现的方式。原理很简单，我们先让一个线程工作，当工作完成之后唤醒另外的一线程,通过上面对RunLoop的说明，相信大家很容易能够理解这些代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (void)runLoopAddDependance&#123;</div><div class="line">    self.runLoopThreadDidFinishFlag = NO;</div><div class="line">    NSLog(@&quot;Start a New Run Loop Thread&quot;);</div><div class="line">    NSThread *runLoopThread = [[NSThread alloc] initWithTarget:self selector:@selector(handleRunLoopThreadTask) object:nil];</div><div class="line">    [runLoopThread start];</div><div class="line">    NSLog(@&quot;Exit handleRunLoopThreadButtonTouchUpInside&quot;);</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        while (!_runLoopThreadDidFinishFlag) &#123;</div><div class="line">            self.myThread = [NSThread currentThread];</div><div class="line">            NSLog(@&quot;Begin RunLoop&quot;);</div><div class="line">            NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">            NSPort *myPort = [NSPort port];</div><div class="line">            [runLoop addPort:myPort forMode:NSDefaultRunLoopMode];</div><div class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">            NSLog(@&quot;End RunLoop&quot;);</div><div class="line">            [self.myThread cancel];</div><div class="line">            self.myThread = nil; </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">- (void)handleRunLoopThreadTask</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Enter Run Loop Thread&quot;);</div><div class="line">    for (NSInteger i = 0; i &lt; 5; i ++) &#123;</div><div class="line">        NSLog(@&quot;In Run Loop Thread, count = %ld&quot;, i);</div><div class="line">        sleep(1);</div><div class="line">    &#125;</div><div class="line">#if 0</div><div class="line">    // 错误示范</div><div class="line">    _runLoopThreadDidFinishFlag = YES;</div><div class="line">    // 这个时候并不能执行线程完成之后的任务，因为Run Loop所在的线程并不知道runLoopThreadDidFinishFlag被重新赋值。Run Loop这个时候没有被任务事件源唤醒。</div><div class="line">    // 正确的做法是使用 &quot;selector&quot;方法唤醒Run Loop。 即如下:</div><div class="line">#endif</div><div class="line">    NSLog(@&quot;Exit Normal Thread&quot;);</div><div class="line">    [self performSelector:@selector(tryOnMyThread) onThread:self.myThread withObject:nil waitUntilDone:NO];</div><div class="line">    // NSLog(@&quot;Exit Run Loop Thread&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>NSURLConnection的执行过程</p>
</blockquote>
<p>在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:</p>
<p><img src="/2017/07/28/iOS开发-RunLoop实例应用/03.png" alt=""></p>
<p>从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">while (!_isEndRequest)</div><div class="line"> &#123; </div><div class="line"> NSLog(@&quot;entered run loop&quot;); </div><div class="line"> [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; </div><div class="line"> &#125; </div><div class="line"> NSLog(@&quot;main finished，task be removed&quot;); </div><div class="line"> - (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123; </div><div class="line"> _isEndRequest = YES; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们就可以解决下面这些疑问了:</p>
<p>1、为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。<br>2、如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。<br>3、既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环</p>
<blockquote>
<p>AFNetWorking中是如何使用RunLoop的?</p>
</blockquote>
<p>在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。<br>为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">+ (NSThread *)networkRequestThread &#123;</div><div class="line">    static NSThread *_networkRequestThread = nil;</div><div class="line">    static dispatch_once_t oncePredicate;</div><div class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</div><div class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</div><div class="line">        [_networkRequestThread start];</div><div class="line">    &#125;);</div><div class="line">    return _networkRequestThread;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)start &#123;</div><div class="line">    </div><div class="line">    [self.lock lock];</div><div class="line">    if ([self isCancelled]) &#123;</div><div class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class="line">    &#125; else if ([self isReady]) &#123;</div><div class="line">        self.state = AFOperationExecutingState;</div><div class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class="line">    &#125;</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>GCD定时器的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)gcdTimer&#123;</div><div class="line">    // get the queue</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">    // creat timer</div><div class="line">    self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">    // config the timer (starting time，interval)</div><div class="line">    // set begining time</div><div class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class="line">    // set the interval</div><div class="line">    uint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class="line">    dispatch_source_set_timer(self.timer, start, interver, 0.0);</div><div class="line">    dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class="line">        // the tarsk needed to be processed async</div><div class="line">        dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">            for (int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">                NSLog(@&quot;gcdTimer&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_resume(self.timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看过很多有关RunLoop的文章，其中要么是主要介绍RunLoop的基本概念，要么是主要讲解RunLoop的底层原理，很少用真正的实例来讲解RunLoop的，这其中有大部分原因是由于大家在项目中很少能用到RunLoop吧。基于这种原因，本文中将用很少的篇幅来对基础内容做
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发-浅谈webViewCookie机制</title>
    <link href="http://yoursite.com/2017/06/15/iOS%E5%BC%80%E5%8F%91-%E6%B5%85%E8%B0%88webViewCookie%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/06/15/iOS开发-浅谈webViewCookie机制/</id>
    <published>2017-06-15T02:50:32.000Z</published>
    <updated>2019-02-26T13:02:06.306Z</updated>
    
    <content type="html"><![CDATA[<p>当你访问一个网站时，浏览器都会帮你主动记录下来你访问的站点设置的Cookie，如果 Cookie 存在的话，会把这些信息放在 CookieStorage 容器中共享，当你下次再访问这个站点时，浏览器会拿着上次保存下来了的Cookie继续去请求。同样适用于ASIHTTPRequest,AFNetworking, Webview等,Cookie常用于一些基于认证的网络请求</p>
<blockquote>
<p>Cookie简介</p>
</blockquote>
<p>Cookie是由服务器端生成，发送给User-Agent（一般是浏览器或者客户端），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站地址时就发送该Cookie给服务器。Cookie分类两类：</p>
<ul>
<li>会话cookie</li>
<li>持久cookie</li>
</ul>
<p>会话 cookie 和持久 cookie 之间唯一的区别就是它们的过期时间。至于cookie会不会持久化到cookie文件中主要看这个cookie的生命周期，和Max-Age或者Expires有关，后面会讲到。</p>
<p>Cookie的属性：</p>
<ul>
<li>name:一个唯一确定的cookie名称。通常来讲cookie的名称是不区分大小写的。</li>
<li>value:存储在cookie中的字符串值。最好为cookie的name和value进行url编码</li>
<li>domain:cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。<code>这个值可以包含子域(如： yq.aliyun.com)，也可以不包含它(如：.aliyun.com，则对于aliyun.com的所有子域都有效).</code></li>
<li>path: 表示这个cookie影响到的路径，浏览器跟会根据这项配置，像指定域中匹配的路径发送cookie。</li>
<li>expires:失效时间，表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有cookie；不过也可以自己设置删除时间。这个值是GMT时间格式，如果客户端和服务器端时间不一致，使用expires就会存在偏差</li>
<li>max-age: 与expires作用相同，用来告诉浏览器此cookie多久过期（单位是秒），而不是一个固定的时间点。正常情况下，max-age的优先级高于expires。</li>
<li>HttpOnly: 告知浏览器不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见。但在http请求张仍然会携带这个cookie。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。这项设置通常在服务器端设置。</li>
<li>secure: 安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了服务器端设置。</li>
</ul>
<p>如何查看Cookie：</p>
<p><strong>浏览器打开百度，按F12</strong></p>
<p><img src="/2017/06/15/iOS开发-浅谈webViewCookie机制/02.png" alt=""></p>
<p><img src="/2017/06/15/iOS开发-浅谈webViewCookie机制/01.jpg" alt=""></p>
<p>可以看到响应头里有个Set-Cookie字段，这个是由服务端设置的cookie，在iOS端会根据cookie的生命周期来自动存储到NSHTTPCookieStorage中，在下次请求时会根据相应的URL domain自动带上相应的Cookie</p>
<blockquote>
<p>认识下NSHTTPCookieStorage</p>
</blockquote>
<p>NSHTTPCookieStorage 实现了一个管理cookie的单例对象(只有一个实例)，每个Cookie都是NSHTTPCookie类的实例，最为一个规则，Cookie在所有应用之间共享并在不同进程之间保持同步。Session Cookie(一个isSessionOnly方法返回YES的Cookie)只能在单一进程中使用。</p>
<blockquote>
<p>iOS htttp网络请求Cookie的读取与写入:</p>
</blockquote>
<p>Cookie必然会通过HTTP的Respone传过来，并且Cookie在Respone中的HTTP header中。不管是什么请求框架，必然会存在Respone对象，比如AFNetworking2.x的operation.response，AFNetworking3.x的task.response等等。。。。</p>
<p><strong>原生NSURLConnection写法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">一.获取cookie</div><div class="line">- (IBAction)cookieTouched:(id)sender &#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://api.skyfox.org/api-test.php&quot;];</div><div class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url]</div><div class="line">                                             cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData</div><div class="line">                                         timeoutInterval:3];</div><div class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc]init];</div><div class="line">    [NSURLConnection sendAsynchronousRequest:request</div><div class="line">                                       queue:queue</div><div class="line">                           completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123;</div><div class="line">                              </div><div class="line">                               //转换NSURLResponse成为HTTPResponse</div><div class="line">                               NSHTTPURLResponse *HTTPResponse = (NSHTTPURLResponse *)response;</div><div class="line">                               //获取headerfields</div><div class="line">                               NSDictionary *fields = [HTTPResponse allHeaderFields];//原生NSURLConnection写法</div><div class="line">                               // NSDictionary *fields = [operation.response allHeaderFields]; //afnetworking写法</div><div class="line">                               NSLog(@&quot;fields = %@&quot;,[fields description]);</div><div class="line"> </div><div class="line">                               //获取cookie方法1</div><div class="line">                               // NSArray *cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:fields forURL:url];</div><div class="line">							   //获取cookie方法2</div><div class="line">                               //NSString *cookieString = [[HTTPResponse allHeaderFields] valueForKey:@&quot;Set-Cookie&quot;];</div><div class="line">                               //获取cookie方法3</div><div class="line">                               NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">                               for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123;</div><div class="line">                                   NSLog(@&quot;cookie%@&quot;, cookie);</div><div class="line">                               &#125;</div><div class="line">                           &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>AFNetworking 写法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">    manager.responseSerializer = [AFCompoundResponseSerializer serializer];</div><div class="line">    //demo中的api返回的是html数据，不是json</div><div class="line">    [manager POST:@&quot;http://dev.skyfox.org/cookie.php&quot; parameters:nil progress:^(NSProgress * _Nonnull uploadProgress) &#123;</div><div class="line">        </div><div class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</div><div class="line">        NSLog(@&quot;\n======================================\n&quot;);</div><div class="line">        NSDictionary *fields = ((NSHTTPURLResponse*)task.response).allHeaderFields;</div><div class="line">        NSLog(@&quot;fields = %@&quot;,[fields description]);</div><div class="line">        NSURL *url = [NSURL URLWithString:@&quot;http://dev.skyfox.org/cookie.php&quot;];</div><div class="line">        NSLog(@&quot;\n======================================\n&quot;);</div><div class="line">        //获取cookie方法1</div><div class="line">        NSArray *cookies = [NSHTTPCookie cookiesWithResponseHeaderFields:fields forURL:url];</div><div class="line">        for (NSHTTPCookie *cookie in cookies) &#123;</div><div class="line">            NSLog(@&quot;cookie,name:= %@,valuie = %@&quot;,cookie.name,cookie.value);</div><div class="line">        &#125;</div><div class="line">        NSLog(@&quot;\n======================================\n&quot;);</div><div class="line">//        //获取cookie方法2</div><div class="line">//        NSString *cookies2 = [((NSHTTPURLResponse*)task.response) valueForKey:@&quot;Set-Cookie&quot;];</div><div class="line">//        NSLog(@&quot;cookies2 = %@&quot;,[cookies2 description]);</div><div class="line"> </div><div class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>手动设置Cookie</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//第一次请求手动设置个cookie</div><div class="line">-(void)test1:(NSString*)urlString&#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://dev.skyfox.org/cookie.php&quot;];</div><div class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div><div class="line">    </div><div class="line">    NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];</div><div class="line">    [cookieProperties setObject:@&quot;username&quot; forKey:NSHTTPCookieName];</div><div class="line">    [cookieProperties setObject:@&quot;my ios cookie&quot; forKey:NSHTTPCookieValue];</div><div class="line">    [cookieProperties setObject:@&quot;dev.skyfox.org&quot; forKey:NSHTTPCookieDomain];</div><div class="line">    [cookieProperties setObject:@&quot;dev.skyfox.org&quot; forKey:NSHTTPCookieOriginURL];</div><div class="line">    [cookieProperties setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];</div><div class="line">    [cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];</div><div class="line">    //注意：Expires是HTTP 1.0标准缓存控制，不建议使用，请使用Cache-Control:max-age代替</div><div class="line">    //[cookieProperties setObject:[NSDate dateWithTimeIntervalSinceNow:60*60] forKey:NSHTTPCookieExpires];//HTTP 1.0标准缓存控制，不建议使用</div><div class="line">     [cookieProperties setObject:@&quot;30000&quot; forKey:NSHTTPCookieMaximumAge];//设置最大生命周期 设置后会持久化cookie直到生命周期结束</div><div class="line">    //[cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieDiscard]; //设置sessionOnly</div><div class="line"> </div><div class="line">    NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];</div><div class="line">    [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];</div><div class="line">    [self.myWebView loadRequest:request];</div><div class="line">&#125;</div><div class="line">//第二次请求会自动带上Cookie</div><div class="line">- (IBAction)test2:(id)sender &#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://dev.skyfox.org/cookie.php&quot;];</div><div class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</div><div class="line">    [self.mywebview2 loadRequest:request];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>request还可以这样设置个Cookie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[request setHTTPShouldHandleCookies:YES];</div><div class="line">[request setValue:[NSString stringWithFormat:@&quot;%@=%@&quot;, [cookie name], [cookie value]] forHTTPHeaderField:@&quot;Cookie&quot;];</div></pre></td></tr></table></figure>
<blockquote>
<p>Cookie的本地缓存策略</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//NSHTTPCookieAcceptPolicyAlways:保存所有cookie，这个是默认值</div><div class="line">//NSHTTPCookieAcceptPolicyNever:不保存任何响应头中的cookie</div><div class="line">//NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain:只保存域请求匹配的cookie</div><div class="line">[[NSHTTPCookieStorage sharedHTTPCookieStorage]setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyNever];</div></pre></td></tr></table></figure>
<blockquote>
<p>清空Cookie</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">  NSArray *cookieArray = [NSArray arrayWithArray:[cookieJar cookies]];</div><div class="line">  for (NSHTTPCookie *obj in cookieArray) &#123;</div><div class="line">    [cookieJar deleteCookie:obj];</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Cookie的持久化存储</p>
</blockquote>
<p>1.服务器端设置Cookie，以PHP为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setcookie(&quot;TestCookie&quot;,&quot;my cookie value&quot;); //没设置失效时间 关闭app后系统不会持久化Cookie</div><div class="line">setcookie(&quot;TestCookie&quot;,&quot;my cookie value&quot;，time()+3600*24); //设置expire失效时间 关闭app后系统自动持久化Cookie</div></pre></td></tr></table></figure>
<p>如果服务器设置了Cookie失效时间expiresDate ,sessionOnly:FALSE会被持久化到文件中，kill掉后系统自动保存，下次启动app会自动加载.binarycookies中的Cookies，以下是一条Cookie输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSHTTPCookie version:0 name:&quot;TestCookie&quot; value:&quot;my+cookie+value&quot; expiresDate:2017-06-15 09:31:09 +0000 created:2017-06-15 09:30:49 +0000 sessionOnly:FALSE domain:&quot;dev.skyfox.org&quot; path:&quot;/&quot; isSecure:FALSE&gt;</div></pre></td></tr></table></figure>
<p>持久化到了文件中，地址是 沙盒的 /Library/Cookies/org.skyfox.iOS-Cookie.binarycookies</p>
<p><img src="/2017/06/15/iOS开发-浅谈webViewCookie机制/03.png" alt=""></p>
<p>2.app端手动存储Cookie</p>
<p>如果没置 NSHTTPCookieMaximumAge 或者Cookie失效时间expiresDate:(null)，sessionOnly:true,kill掉后系统不会自动保存Cookie，如果想持久化Cookie 模仿浏览器存住Cookie，使用NSUserDefaults存下即可,以下是一条Cookie输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;NSHTTPCookie version:0 name:&quot;TestCookie&quot; value:&quot;my+cookie+value&quot; expiresDate:(null) created:2017-06-15 09:33:34 +0000 sessionOnly:TRUE domain:&quot;dev.skyfox.org&quot; path:&quot;/&quot; isSecure:FALSE&gt;</div></pre></td></tr></table></figure>
<p>手动保存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//合适的时机持久化Cookie</div><div class="line">- (void)saveCookies&#123;</div><div class="line">    NSData *cookiesData = [NSKeyedArchiver archivedDataWithRootObject: [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]];</div><div class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</div><div class="line">    [defaults setObject: cookiesData forKey:@&quot;org.skyfox.cookiesave&quot;];</div><div class="line">    [defaults synchronize];</div><div class="line">&#125;</div><div class="line">//合适的时机加载持久化后Cookie 一般都是app刚刚启动的时候</div><div class="line">- (void)loadSavedCookies&#123;</div><div class="line">    NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData: [[NSUserDefaults standardUserDefaults] objectForKey: @&quot;org.skyfox.cookiesave&quot;]];</div><div class="line">    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];</div><div class="line">    for (NSHTTPCookie *cookie in cookies)&#123;</div><div class="line">        NSLog(@&quot;cookie,name:= %@,valuie = %@&quot;,cookie.name,cookie.value);</div><div class="line">        [cookieStorage setCookie: cookie];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于同名cookie后者会覆盖前者</p>
<h2 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a><a href="https://github.com/Henry519/ios_cookie" target="_blank" rel="external">demo地址</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你访问一个网站时，浏览器都会帮你主动记录下来你访问的站点设置的Cookie，如果 Cookie 存在的话，会把这些信息放在 CookieStorage 容器中共享，当你下次再访问这个站点时，浏览器会拿着上次保存下来了的Cookie继续去请求。同样适用于ASIHTTPReq
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发-Safari调试WebView页面</title>
    <link href="http://yoursite.com/2017/06/06/iOS%E5%BC%80%E5%8F%91-Safari%E8%B0%83%E8%AF%95WebView%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2017/06/06/iOS开发-Safari调试WebView页面/</id>
    <published>2017-06-06T07:13:30.000Z</published>
    <updated>2019-02-26T02:48:46.263Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发过程中，难免会加入html5页面来实现文章详情等等类似功能。我们都知道火狐等PC浏览器有类似firebug，审查元素等工具来调试网页样式与脚本，查看请求参数与请求头等等。在iOS开发中，这些网页检查器功能也是存在的（无论是模拟器还是真机），我们需要用到Mac自带的浏览器Safari。所以，本文将讲解使用Safari对iOS程序中的WebView进行调试的小技巧。</p>
<blockquote>
<p>1、 打开模拟器/真机的开发者模式（模拟器是默认开启的）</p>
</blockquote>
<p>“设置”-&gt;”Safari”-&gt;”高级”-&gt;”Web检查器” 打开</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/01.png" alt=""></p>
<blockquote>
<p>2、打开Mac上Safari的开发者模式</p>
</blockquote>
<p>开启 Safari -&gt;“偏好设置” -&gt; “高级” -&gt; “在菜单栏中显示开发选项”</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/02.png" alt=""></p>
<blockquote>
<p>3、在模拟器／真机中打开APP中的WebView页面，并打开Safari</p>
</blockquote>
<p>当有WebView加载网页时，打开Mac Safari调试模式 网页检查器。 “开发” -&gt;“Simulator或者你的真机名称” -&gt;“网页文档名称”</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/03.png" alt=""></p>
<p>在弹出的网页检查器中，可以看到当前正在加载网页的各种信息，包括元素源码、网络、资源与脚本、控制台输出等。并且它和Web前端的调试方式相同，你可以直接修改网页的CSS样式，对网页布局源码等进行修改，使用调试器进行脚本调试，而不需要重新运行整个APP。</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/04.png" alt=""></p>
<blockquote>
<p>4、JSPatch调试</p>
</blockquote>
<p>当有JavaScriptContext加载时，打开Mac Safari调试模式 网页检查器。 “开发” -&gt;“Simulator或者你的真机名称” -&gt;“JSContext”。<br><img src="/2017/06/06/iOS开发-Safari调试WebView页面/06.png" alt=""></p>
<p>在资源tab中即可进行断点调试了</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/05.png" alt=""></p>
<p>调试器tab中也可以进行单步调试等详细工作</p>
<p><img src="/2017/06/06/iOS开发-Safari调试WebView页面/07.png" alt=""></p>
<p>所有资源列出了 JSPatch 所有执行中的脚本文件，点开文件后可以对其进行断点调试。（有时候调试器tab识别的文件不全）。<br>通过<code>[JPEngine evaluateScript:script]</code>接口执行的脚本，在资源列表里都表示为 main.js。<br>通过 <code>[JPEngine evaluateScriptWithPath:filePath]</code> 接口执行的脚本，在资源列表里会以原文件名表示</p>
<h3 id="最后如果还不出现Simulator或者你的真机名称，尝试重启Mac-Safari！！！"><a href="#最后如果还不出现Simulator或者你的真机名称，尝试重启Mac-Safari！！！" class="headerlink" title="最后如果还不出现Simulator或者你的真机名称，尝试重启Mac Safari！！！"></a>最后如果还不出现Simulator或者你的真机名称，尝试重启Mac Safari！！！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，难免会加入html5页面来实现文章详情等等类似功能。我们都知道火狐等PC浏览器有类似firebug，审查元素等工具来调试网页样式与脚本，查看请求参数与请求头等等。在iOS开发中，这些网页检查器功能也是存在的（无论是模拟器还是真机），我们需要用到Mac自带
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>IOS开发-获取唯一设备标识的方法</title>
    <link href="http://yoursite.com/2017/03/06/UUID%E5%85%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/06/UUID全解/</id>
    <published>2017-03-06T01:26:32.000Z</published>
    <updated>2019-02-26T13:06:05.753Z</updated>
    
    <content type="html"><![CDATA[<pre><code>在开发过程中，我们经常会被要求获取每个设备的唯一标识，以便后台做相应的处理。
我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。具体可分为以下几种：
1、UDID
2、UUID
3、IDFA
4、IDFV
4、MAC(已经被禁用，除了5.0以前，哪位大神还在用此等上古神器)
</code></pre><blockquote>
<p>一、UDID</p>
</blockquote>
<h3 id="什么是UDID"><a href="#什么是UDID" class="headerlink" title="什么是UDID"></a>什么是UDID</h3><p>UDID 「Unique Device Identifier Description」是由子母和数字组成的40个字符串的序号，用来区别每一个唯一的iOS设备，包括 iPhones, iPads, 以及 iPod touches，这些编码看起来是随机的，实际上是跟硬件设备特点相联系的，另外你可以到iTunes，pp助手或itools等软件查看你的udid（设备标识）。</p>
<p>如下图所示：<img src="/2017/03/06/UUID全解/01.png" alt=""></p>
<h3 id="UDID是用来干什么的？"><a href="#UDID是用来干什么的？" class="headerlink" title="UDID是用来干什么的？"></a>UDID是用来干什么的？</h3><p>UDID可以关联其它各种数据到相关设备上。例如，连接到开发者账号，可以允许在发布前让设备安装或测试应用；也可以让开发者获得iOS测试版进行体验。苹果用UDID连接到苹果的ID，这些设备可以自动下载和安装从App Store购买的应用、保存从iTunes购买的音乐、帮助苹果发送推送通知、即时消息。 在iOS 应用早期，UDID被第三方应用开发者和网络广告商用来收集用户数据，可以用来关联地址、记录应用使用习惯……以便推送精准广告</p>
<pre><code>大多数应用都会用到苹果设备的UDID号，UDID通常有以下两种用途：

* 用于一些统计与分析目的；【第三方统计工具如友盟，广告商如ADMOB等。

* 将UDID作为用户ID来唯一识别用户，省去用户名，密码等注册过程。
</code></pre><h3 id="为什么苹果反对开发人员使用UDID？"><a href="#为什么苹果反对开发人员使用UDID？" class="headerlink" title="为什么苹果反对开发人员使用UDID？"></a>为什么苹果反对开发人员使用UDID？</h3><p>iOS 2.0版本以后UIDevice提供一个获取设备唯一标识符的方法uniqueIdentifier，通过该方法我们可以获取设备的序列号，这个也是目前为止唯一可以确认唯一的标示符。 许多开发者把UDID跟用户的真实姓名、密码、住址、其它数据关联起来；网络窥探者会从多个应用收集这些数据，然后顺藤摸瓜得到这个人的许多隐私数据。同时大部分应用确实在频繁传输UDID和私人信息。 为了避免集体诉讼，苹果最终决定在iOS 5 的时候，将这一惯例废除，开发者被引导生成一个唯一的标识符，只能检测应用程序，其他的信息不提供。<code>现在应用试图获取UDID已被禁止且不允许上架</code>。<br>所以这个方法作废。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//UDID , 已废除</div><div class="line">NSString *udid = [[UIDevice currentDevice] uniqueIdentifier];</div></pre></td></tr></table></figure>
<blockquote>
<p>二、UUID</p>
</blockquote>
<h3 id="什么是UUID-Universally-Unique-Identifier"><a href="#什么是UUID-Universally-Unique-Identifier" class="headerlink" title="什么是UUID(Universally Unique Identifier)"></a>什么是UUID(Universally Unique Identifier)</h3><p>UUID是Universally Unique Identifier的缩写，中文意思是通用唯一识别码。它是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。这样，每个人都可以建立不与其它人冲突的 UUID。在此情况下，就不需考虑数据库建立时的名称重复问题。苹果公司建议使用UUID为应用生成唯一标识字符串。 </p>
<p>获得的UUID值系统没有存储, 而且每次调用得到UUID，系统都会返回一个新的唯一标示符。如果你希望存储这个标示符，那么需要自己将其存储到NSUserDefaults, Keychain, Pasteboard或其它地方。目前大部分应用存的是UUID,它是苹果再iOS6后提供的一个获取大随机数的方法。UUID, 全球独立标识(Globally Unique Identifier)，据wiki说UUID随机数算法得到的数重复概率为170亿分之一，170亿分之一什么概念？可以告诉你买一注双色球的中奖概率是1700万分之一。</p>
<ul>
<li>CFUUID</li>
</ul>
<p>从iOS2.0开始，CFUUID就已经出现了。它是CoreFoundatio包的一部分，因此API属于C语言风格。CFUUIDCreate 方法用来创建CFUUIDRef，并且可以获得一个相应的NSString，如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFUUIDRef cfuuid = CFUUIDCreate(kCFAllocatorDefault);</div><div class="line">NSString *cfuuidString = (NSString*)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, cfuuid));</div></pre></td></tr></table></figure>
<p>获得的这个CFUUID值系统并没有存储。每次调用CFUUIDCreate，系统都会返回一个新的唯一标示符。如果你希望存储这个标示符，那么需要自己将其存储到NSUserDefaults, Keychain, Pasteboard或其它地方。</p>
<ul>
<li>NSUUID</li>
</ul>
<p>NSUUID在iOS 6中才出现，这跟CFUUID几乎完全一样，只不过它是Objective-C接口。+ (id)UUID 是一个类方法，调用该方法可以获得一个UUID。通过下面的代码可以获得一个UUID字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *uuid = [[NSUUID UUID] UUIDString];</div></pre></td></tr></table></figure>
<p>跟CFUUID一样，这个值系统也不会存储，每次调用的时候都会获得一个新的唯一标示符。如果要存储的话，你需要自己存储。在我读取NSUUID时，注意到获取到的这个值跟CFUUID完全一样（不过也可能不一样）</p>
<blockquote>
<p>三、IDFA（identifierForIdentifier）</p>
</blockquote>
<h3 id="什么是IDFA"><a href="#什么是IDFA" class="headerlink" title="什么是IDFA"></a>什么是IDFA</h3><p>广告标示符，在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的。但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。<br>它是iOS 6中另外一个新的方法，提供了一个方法advertisingIdentifier，通过调用该方法会返回一个NSUUID实例，最后可以获得一个UUID，由系统存储着的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &lt;AdSupport/AdSupport.h&gt;</div><div class="line">NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</div></pre></td></tr></table></figure>
<p>不过即使这是由系统存储的，但是有几种情况下，会重新生成广告标示符。如果用户完全重置系统（(设置程序 -&gt; 通用 -&gt; 还原 -&gt; 还原位置与隐私) ，这个广告标示符会重新生成。另外如果用户明确的还原广告(设置程序-&gt; 通用 -&gt; 关于本机 -&gt; 广告 -&gt; 还原广告标示符) ，那么广告标示符也会重新生成。<br>关于广告标示符的还原，有一点需要注意：如果程序在后台运行，此时用户“还原广告标示符”，然后再回到程序中，此时获取广 告标示符并不会立即获得还原后的标示符。必须要终止程序，然后再重新启动程序，才能获得还原后的广告标示符。<br>所以IDFA也不可以作为获取唯一标识的方法，来识别用户。</p>
<h4 id="注意：Appstore禁止不使用广告而采集IDFA的app上架。"><a href="#注意：Appstore禁止不使用广告而采集IDFA的app上架。" class="headerlink" title="注意：Appstore禁止不使用广告而采集IDFA的app上架。"></a><code>注意：Appstore禁止不使用广告而采集IDFA的app上架。</code></h4><blockquote>
<p>四、IDFV(identifierForVendor)</p>
</blockquote>
<h3 id="什么是IDFV"><a href="#什么是IDFV" class="headerlink" title="什么是IDFV"></a>什么是IDFV</h3><p>Vendor标示符，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个IDFV的值。和IDFA不同的是，IDFV的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。<br>它是iOS 6中新增的，跟advertisingIdentifier一样，该方法返回的是一个 NSUUID对象，可以获得一个UUID。如果满足条件“相同的一个程序里面-相同的vendor-相同的设备”，那么获取到的这个属性值就不会变。如果是“相同的程序-相同的设备-不同的vendor，或者是相同的程序-不同的设备-无论是否相同的vendor”这样的情况，那么这个值是不会相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString];</div></pre></td></tr></table></figure>
<h5 id="但是如果用户将属于此Vender的所有App卸载，则IDFV的值会被重置，即再重装此Vender的App，IDFV的值和之前不同。"><a href="#但是如果用户将属于此Vender的所有App卸载，则IDFV的值会被重置，即再重装此Vender的App，IDFV的值和之前不同。" class="headerlink" title="但是如果用户将属于此Vender的所有App卸载，则IDFV的值会被重置，即再重装此Vender的App，IDFV的值和之前不同。"></a><code>但是如果用户将属于此Vender的所有App卸载，则IDFV的值会被重置，即再重装此Vender的App，IDFV的值和之前不同。</code></h5><blockquote>
<p>五、MAC Address</p>
</blockquote>
<h3 id="什么是MAC"><a href="#什么是MAC" class="headerlink" title="什么是MAC"></a>什么是MAC</h3><p>MAC(Medium/Media Access Control)地址，用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节（48位）。其中，前三个字节是由IEEE的注册管理机构 RA负责给不同厂家分配的代码(高位24位)，也称为“编制上唯一的标识符” （Organizationally Unique Identifier)，后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。 </p>
<p>MAC地址在网络上用来区分设备的唯一性，接入网络的设备都有一个MAC地址，他们肯定都是不同的，是唯一的。一部iPhone上可能有多个MAC地址，包括WIFI的、SIM的等，但是iTouch和iPad上就有一个WIFI的，因此只需获取WIFI的MAC地址就好了，也就是en0的地址。<br>形象的说，MAC地址就如同我们身份证上的身份证号码，具有全球唯一性。这样就可以非常好的标识设备唯一性，类似与苹果设备的UDID号，通常的用途有：<br>1）用于一些统计与分析目的，利用用户的操作习惯和数据更好的规划产品；<br>2）作为用户ID来唯一识别用户，可以用游客身份使用app又能在服务器端保存相应的信息，省去用户名、密码等注册过程。</p>
<h3 id="如何使用Mac地址生成设备的唯一标识呢？"><a href="#如何使用Mac地址生成设备的唯一标识呢？" class="headerlink" title="如何使用Mac地址生成设备的唯一标识呢？"></a>如何使用Mac地址生成设备的唯一标识呢？</h3><p>主要分三种：</p>
<pre><code>1、直接使用“MAC Address” 
2、使用“MD5(MAC Address)” 
3、使用“MD5(Mac Address+bundle_id)”获得“机器＋应用”的唯一标识（bundle_id 是应用的唯一标识）
</code></pre><p>iOS7之前，因为Mac地址是唯一的， 一般app开发者会采取第3种方式来识别安装对应app的设备。为什么会使用它？在iOS5之前，都是使用UDID的，后来被禁用。苹果推荐使用UUID 但是也有诸多问题，从而使用MAC地址。而MAC地址跟UDID一样，存在隐私问题，现在苹果新发布的iOS7上，如果请求Mac地址都会返回一个固定值，那么Mac Address+bundle_id这个值大家的设备都变成一致的啦，跟UDID一样相当于被禁用, 所以Mac Address 是不能够被使用为获取设备唯一标识的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/sysctl.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">#include &lt;net/if.h&gt;</div><div class="line">#include &lt;net/if_dl.h&gt;</div><div class="line"> </div><div class="line">  int mib[6];</div><div class="line">    size_t len;</div><div class="line">    char *buf;</div><div class="line">    unsigned char *ptr;</div><div class="line">    struct if_msghdr *ifm;</div><div class="line">    struct sockaddr_dl *sdl;</div><div class="line"> </div><div class="line">    mib[0] = CTL_NET;</div><div class="line">    mib[1] = AF_ROUTE;</div><div class="line">    mib[2] = 0;</div><div class="line">    mib[3] = AF_LINK;</div><div class="line">    mib[4] = NET_RT_IFLIST;</div><div class="line"> </div><div class="line">    if ((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;</div><div class="line">        printf(&quot;Error: if_nametoindex error\n&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    if (sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;</div><div class="line">        printf(&quot;Error: sysctl, take 1\n&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    if ((buf = malloc(len)) == NULL) &#123;</div><div class="line">        printf(&quot;Could not allocate memory. error!\n&quot;);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    if (sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;</div><div class="line">        printf(&quot;Error: sysctl, take 2&quot;);</div><div class="line">        free(buf);</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ifm = (struct if_msghdr *)buf;</div><div class="line">    sdl = (struct sockaddr_dl *)(ifm + 1);</div><div class="line">    ptr = (unsigned char *)LLADDR(sdl);</div><div class="line">    NSString *macStr = [NSString stringWithFormat:@&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;,*ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];</div><div class="line">    free(buf);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多, 才发现原来没有一种方法是可行的。没错, 其实自从苹果废除UDID后, 就不能达到获取设备真正的唯一标识了。因为这些方法中导致获取的唯一标示产生改变的原因, 或是重新调用方法, 或是重启设备, 或是卸载应用, 或是还原某些标识, 或者刷新系统…<br>所以, 不能达到从根本上获取唯一标识, 我们只能做到尽可能接近。下面是我用过的方法。</p>
<h3 id="如何正确的获取设备的唯一标识"><a href="#如何正确的获取设备的唯一标识" class="headerlink" title="如何正确的获取设备的唯一标识"></a>如何正确的获取设备的唯一标识</h3><p>我用的方法是将获取的UUID永久存储在设备的KeyChain中, 这个方法在应用第一次启动时, 将获取的UUID存储进KeyChain中, 每次取的时候, 检查本地钥匙串中有没有, 如果没有则需要将获取的UUID存储进去。当你重启设备, 卸载应用再次安装,都不影响, 只是当设备刷机时, KeyChain会清空, 才会消失, 才会失效。<br>不只是这一种方法, 你也可以保存除UUID之外,其他合适的标识, 但利用KeyChain去存储标识的方式应该是最接近的。</p>
<h2 id="重点：利用keyChain和UUID永久获得设备的唯一标识"><a href="#重点：利用keyChain和UUID永久获得设备的唯一标识" class="headerlink" title="重点：利用keyChain和UUID永久获得设备的唯一标识"></a>重点：利用keyChain和UUID永久获得设备的唯一标识</h2><h3 id="什么是keychain"><a href="#什么是keychain" class="headerlink" title="什么是keychain"></a>什么是keychain</h3><pre><code>苹果增加更安全的存储方式：Keychain（相对于NSUserDefaults数据以明文的形式保存在）
提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，
每个iOS程序都有一个独立的keychain存储，将数据加密后存储在本地,更安全.
当你删除APP后Keychain存储的数据不会删除，所以在重装App后，Keychain里的数据还能使用。
从ios 3.0开始，跨程序分享keychain变得可行而NSUserDefaults存储的数据会随着APP而删掉
</code></pre><p>话不多说，下面看看怎么用keychain方式存储UUID，达到删除应用重新安装后获取的UUID不会变（但系统reset后keychain存储的数据会消失。）<br>使用keychain请不要忘记引入Security包，引入头文件 <code>&lt;Security/Security.h&gt;</code></p>
<h4 id="定义一个工具类用户存储用户数据，提供存、取、删三个接口。"><a href="#定义一个工具类用户存储用户数据，提供存、取、删三个接口。" class="headerlink" title="定义一个工具类用户存储用户数据，提供存、取、删三个接口。"></a>定义一个工具类用户存储用户数据，提供存、取、删三个接口。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  MXKeyChain.h</div><div class="line">//  keyChainDemo</div><div class="line">//</div><div class="line">//  Created by Henry on 2017/3/4.</div><div class="line">//  Copyright © 2017年 无届网络科技. All rights reserved.</div><div class="line">//</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;Security/Security.h&gt;</div><div class="line">@interface MXKeyChain : NSObject</div><div class="line">/**</div><div class="line"> *  存储字符串到 KeyChain</div><div class="line"> */</div><div class="line">+ (void)keyChainSaveString:(NSString *)string WithSecureKey:(NSString *)secureKey;</div><div class="line">/**</div><div class="line"> *  从 KeyChain 中读取存储的字符串</div><div class="line"> */</div><div class="line">+ (NSString *)keyChainLoadStringWithSecureKey:(NSString *)secureKey;</div><div class="line">/**</div><div class="line"> *  删除 KeyChain 信息</div><div class="line"> */</div><div class="line">+ (void)keyChainDeleteStringWithSecureKey:(NSString *)secureKey;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">//  ViewController.m</div><div class="line">//  keyChainDemo</div><div class="line">//</div><div class="line">//  Created by Henry on 2017/3/3.</div><div class="line">//  Copyright © 2017年 无届网络科技. All rights reserved.</div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;MXKeyChain.h&quot;</div><div class="line">static NSString *const UUIDKEY = @&quot;UUIDKEY&quot;;</div><div class="line">@interface ViewController ()</div><div class="line">- (IBAction)loadUUID;</div><div class="line">@end</div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    [self loadUUID];</div><div class="line">&#125;</div><div class="line">//每次卸载应用重装加载的UUID都不会变，但重置系统后就没有数据了。</div><div class="line">- (IBAction)loadUUID &#123;</div><div class="line">    NSString *uuidStr = [MXKeyChain keyChainLoadStringWithSecureKey:UUIDKEY];</div><div class="line">    if (!uuidStr.length)&#123;</div><div class="line">        uuidStr = [[NSUUID UUID] UUIDString];//此方法每次加载的UUID都不一样</div><div class="line">        [MXKeyChain keyChainSaveString:uuidStr WithSecureKey:UUIDKEY];</div><div class="line">    &#125;</div><div class="line">    NSLog(@&quot;UUID: %@&quot;,uuidStr);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h2 id="本次演示个人用的demo"><a href="#本次演示个人用的demo" class="headerlink" title="本次演示个人用的demo"></a>本次演示个人用的demo</h2><h3 id="在项目中-导入MXKeyChain-h-MXKeyChain-m调用即可"><a href="#在项目中-导入MXKeyChain-h-MXKeyChain-m调用即可" class="headerlink" title="在项目中,导入MXKeyChain.h MXKeyChain.m调用即可"></a>在项目中,导入<code>MXKeyChain.h MXKeyChain.m</code>调用即可</h3><h3 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a><a href="https://github.com/Henry519/keychainDemo" target="_blank" rel="external">demo地址</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;在开发过程中，我们经常会被要求获取每个设备的唯一标识，以便后台做相应的处理。
我们来看看有哪些方法来获取设备的唯一标示，然后再分析下这些方法的利弊。具体可分为以下几种：
1、UDID
2、UUID
3、IDFA
4、IDFV
4、MAC(已经被禁用，除了5.
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS之UI-CAShapeLayer</title>
    <link href="http://yoursite.com/2017/03/01/iOS%E4%B9%8BUI-CAShapeLayer/"/>
    <id>http://yoursite.com/2017/03/01/iOS之UI-CAShapeLayer/</id>
    <published>2017-03-01T09:07:36.000Z</published>
    <updated>2019-02-26T03:25:06.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内容大纲："><a href="#内容大纲：" class="headerlink" title="内容大纲："></a>内容大纲：</h3><pre><code>1. CAShapeLayer简介
2. 贝塞尔曲线与CAShapeLayer的关系
3. strokeStart和strokeEnd 动画
4. 用CAShapeLayer实现进度条效果，以及更加复杂的效果
</code></pre><h2 id="1-CAShapeLayer简介"><a href="#1-CAShapeLayer简介" class="headerlink" title="1.CAShapeLayer简介"></a>1.CAShapeLayer简介</h2><ul>
<li>CAShapeLayer继承自CALayer，可以使用CALayer的所有属性值</li>
<li>CAShapeLayer需要与贝塞尔曲线配合使用才有意义</li>
<li>使用CAShapeLayer与贝塞尔曲线可以实现不在view的drawRect方法中画出有一些想要的图形</li>
<li>CAShapeLayer属于CoreAnimation框架，其动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况。</li>
<li>个人经验：可以重写UIView的子类中的drawRect来实现进度条效果，但是UIView的drawRect是用CPU渲染实现的，而使用CAShapeLayer效率更高，因为它用的是GPU渲染。话不多说直接贴代码</li>
</ul>
<p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_1.png" alt=""><br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_2.png" alt=""><br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_3.png" alt=""><br>效果：<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_4.gif" alt=""><br>虽然说，直接更改另外创建的CALayer以及其子类，会触发隐式动画，但是直接更改CAShapeLayer的path的值，变化过程没有渐变移动的效果，所以这里就需要<br>使用核心动画CABasicAnimation来帮忙实现，未使用核心动画验证效果在后面验证。</p>
<h2 id="2-贝塞尔曲线与CAShapeLayer的关系"><a href="#2-贝塞尔曲线与CAShapeLayer的关系" class="headerlink" title="2.贝塞尔曲线与CAShapeLayer的关系"></a>2.贝塞尔曲线与CAShapeLayer的关系</h2><ul>
<li>CAShapeLayer中有Shape这个单词，顾名思义，它需要一个形状才能生效</li>
<li>贝塞尔曲线可以创建基于矢量的路径</li>
<li>贝塞尔曲线给CAShapeLayer提供路径，CAShapeLayer在提供的路径中进行渲染，路径会闭环，所以路径绘制出了Shape</li>
<li>用于CAShapeLayer的贝塞尔曲线做为path，其path实一个首尾相接的闭环的曲线，即使该贝塞尔曲线不是一个闭环的曲线</li>
</ul>
<h4 id="如何建立贝塞尔曲线和CAShapeLayer的联系："><a href="#如何建立贝塞尔曲线和CAShapeLayer的联系：" class="headerlink" title="如何建立贝塞尔曲线和CAShapeLayer的联系："></a>如何建立贝塞尔曲线和CAShapeLayer的联系：</h4><ul>
<li>类:CAShapeLayer</li>
<li><p>属性:path</p>
<ul>
<li>值:可以是贝塞尔曲线对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *circle = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0,0,200,100)];</div><div class="line">shape.path = circle.CGPath;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性：fillColor 修改贝塞尔曲线的填充颜色</p>
<ul>
<li>值：CGColor对象</li>
</ul>
</li>
<li>属性：maskToBounds <ul>
<li>值：YES 会让超出CAShapeLayer的部分不会显示</li>
</ul>
</li>
</ul>
<p>一阶贝塞尔曲线<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_5.gif" alt=""></p>
<p>二阶贝塞尔曲线<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_6.gif" alt=""></p>
<p>三阶贝塞尔曲线<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_7.gif" alt=""></p>
<p>四阶贝塞尔曲<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_8.gif" alt=""></p>
<p>五阶贝塞尔曲线<br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_9.gif" alt=""></p>
<h5 id="然后是通过代码直接体现贝塞尔曲线和CAShapeLayer之间的关系："><a href="#然后是通过代码直接体现贝塞尔曲线和CAShapeLayer之间的关系：" class="headerlink" title="然后是通过代码直接体现贝塞尔曲线和CAShapeLayer之间的关系："></a>然后是通过代码直接体现贝塞尔曲线和CAShapeLayer之间的关系：</h5><p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_10.png" alt=""></p>
<h2 id="3、strokeStart与strokeEnd动画"><a href="#3、strokeStart与strokeEnd动画" class="headerlink" title="3、strokeStart与strokeEnd动画"></a>3、strokeStart与strokeEnd动画</h2><ul>
<li>将ShapeLayer的fillColor设置成透明背景</li>
<li>设置线条的宽度（lineWidth）的值</li>
<li>设置线条的颜色</li>
<li>将strokeStart值设定成0，然后让strokeEnd的值变化触发隐式动画</li>
<li><p>类：CAShapeLayer</p>
<ul>
<li><p>属性：</p>
<ul>
<li>strokeStart</li>
<li>strokeEnd<ul>
<li>注意 ：strokeEnd的值一定要比strokeStart的大</li>
<li>范围 ：(0~1)</li>
<li>处理方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shapeLayer.strokeStart = valueOne &lt; valueTwo ? valueOne : valueTwo;</div><div class="line">shapeLayer.strokeStart = valueOne &gt; valueTwo ? valueOne : valueTwo;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>属性：</p>
<ul>
<li>lineWidth 线条的宽度</li>
<li>strokeColor 线条的颜色 </li>
<li>值：CGColor</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_11.png" alt="">  </p>
<h5 id="然后为了能实现圆形进度条的效果："><a href="#然后为了能实现圆形进度条的效果：" class="headerlink" title="然后为了能实现圆形进度条的效果："></a>然后为了能实现圆形进度条的效果：</h5><p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_12.png" alt="">  </p>
<h5 id="效果就是："><a href="#效果就是：" class="headerlink" title="效果就是："></a>效果就是：</h5><p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_13.gif" alt=""></p>
<h5 id="将上面的strokeStart也设置，但是注意：strokeStart必须要小于strokeEnd，否则会不画出线的情况。"><a href="#将上面的strokeStart也设置，但是注意：strokeStart必须要小于strokeEnd，否则会不画出线的情况。" class="headerlink" title="将上面的strokeStart也设置，但是注意：strokeStart必须要小于strokeEnd，否则会不画出线的情况。"></a>将上面的strokeStart也设置，但是注意：strokeStart必须要小于strokeEnd，否则会不画出线的情况。</h5><p><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_14.png" alt=""><br><img src="/2017/03/01/iOS之UI-CAShapeLayer/pic_15.gif" alt=""></p>
<h2 id="4、用CAShapeLayer实现圆形进度条效果，以及更复杂综合起来的动画效果"><a href="#4、用CAShapeLayer实现圆形进度条效果，以及更复杂综合起来的动画效果" class="headerlink" title="4、用CAShapeLayer实现圆形进度条效果，以及更复杂综合起来的动画效果"></a>4、用CAShapeLayer实现圆形进度条效果，以及更复杂综合起来的动画效果</h2><h3 id="综合示例源码请看：源码"><a href="#综合示例源码请看：源码" class="headerlink" title="综合示例源码请看：源码"></a>综合示例源码请看：<a href="https://github.com/Henry519/UIView" target="_blank" rel="external">源码</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内容大纲：&quot;&gt;&lt;a href=&quot;#内容大纲：&quot; class=&quot;headerlink&quot; title=&quot;内容大纲：&quot;&gt;&lt;/a&gt;内容大纲：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. CAShapeLayer简介
2. 贝塞尔曲线与CAShapeLayer的关系
3. stro
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
